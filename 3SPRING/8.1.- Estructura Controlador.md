---
title: 8.2.- Estructura Controladors 
parent: 8.- Controladors.
grand_parent: SPRING
has_children: true
layout: default
nav_order: 10
---




# **Estructura per al `RestController`**
Podem estructurar el nostre `RestController` de moltes maneres segons el nivell d‚Äôabstracci√≥ i modularitat que vullgam aplicar. Els m√©s comuns s√≥n:

### 1Ô∏è **Directament amb el Repository (`@RestController` + `@Repository`)**  

   - El `RestController` crida directament els `JpaRepository`, sense cap capa de servei.  
   - **Avantatges:**  
     - Codi senzill i r√†pid de desenvolupar.  
     - Menys classes i menys codi a mantenir.  
   - **Inconvenients:**  
     - Dif√≠cil d‚Äôampliar si cal modificar la l√≤gica de negoci.  
     - No permet reutilitzar la l√≤gica de negoci en altres llocs.  
     - No separa clarament responsabilitats.

### 2Ô∏è **Amb una Capa de Serveis (`@Service`)**  
   - El `RestController` crida un `Service`, que cont√© la l√≤gica de negoci i despr√©s crida al `Repository`.  
   - **Avantatges:**  
     - Separa les responsabilitats: el `Controller` nom√©s rep les peticions, el `Service` s‚Äôencarrega de la l√≤gica i el `Repository` accedeix a la BD.  
     - F√†cil de modificar o afegir nova l√≤gica sense tocar el `Controller`.  
   - **Inconvenients:**  
     - M√©s classes, pot semblar sobreenginyeria si l‚ÄôAPI √©s molt simple.

### 3Ô∏è **Amb `DTOs` (Data Transfer Objects)**  
   - **Com funciona?** Utilitza **DTOs** per encapsular les dades que s‚Äôenvien o reben a l‚ÄôAPI, en lloc d‚Äôexposar directament les entitats JPA.  
   - **Avantatges:**  
     - Protegeix l‚Äôestructura interna de la BD (no exposem directament les entitats JPA).  
     - Evita problemes de **Lazy Loading** amb entitats relacionades.  
     - Permet personalitzar les respostes i no dependre de la BD.  
   - **Inconvenients:**  
     - Necessita classes addicionals (DTOs).  
     - Es requereix mapeig entre **Entitats <-> DTOs** (per exemple, amb **MapStruct** o manualment).  

**Esta √©s la millor opci√≥ per a projectes escalables:**  
- Utilitzar **Capa de Servei + DTOs**, perqu√® separa b√© les responsabilitats i protegeix l‚Äôestructura de la BD.

---

### **Estructura Recomanada**
- 1.- **Repositoris (DAO)**
  - `CiutatRepository.java`
  - `ProvinciaRepository.java`
  - `PaisRepository.java`
  - `FranquiciaRepository.java`
  - `CiutatFranquiciaRepository.java`

- 2Ô∏è **Serveis (Business Logic)**
  - `CiutatService.java`
  - `ProvinciaService.java`
  - `PaisService.java`
  - `FranquiciaService.java`
  - `CiutatFranquiciaService.java`

- 3Ô∏è **DTOs**
  - `CiutatDTO.java`
  - `ProvinciaDTO.java`
  - `PaisDTO.java`
  - `FranquiciaDTO.java`
  - `CiutatFranquiciaDTO.java`

- 4Ô∏è **Controllers**
  - `CiutatController.java`
  - `ProvinciaController.java`
  - `PaisController.java`
  - `FranquiciaController.java`
  - `CiutatFranquiciaController.java`

---

## **Exemple d‚Äôimplementaci√≥**
üîπ **DTO per a Ciutat**
```java
public class CiutatDTO {
    private Long id;
    private String nom;
    private int poblacio;
    private String descripcio;
    private String imatge;
    private String nomProvincia; // Evitem retornar l‚Äôobjecte complet

    public CiutatDTO(Ciutat ciutat) {
        this.id = ciutat.getId();
        this.nom = ciutat.getNom();
        this.poblacio = ciutat.getPoblacio();
        this.descripcio = ciutat.getDescripcio();
        this.imatge = ciutat.getImatge();
        this.nomProvincia = ciutat.getProvincia().getNom();
    }

    // Getters i Setters...
}
```

- **CiutatRepository (DAO)**
```java
@Repository
public interface CiutatRepository extends JpaRepository<Ciutat, Long> {
    List<Ciutat> findByPoblacioGreaterThan(int poblacio);
}
```

- **CiutatService**
```java
@Service
public class CiutatService {
    @Autowired
    private CiutatRepository ciutatRepository;

    public List<CiutatDTO> obtenirTotesLesCiutats() {
        List<Ciutat> ciutats = ciutatRepository.findAll();
        return ciutats.stream().map(CiutatDTO::new).collect(Collectors.toList());
    }

    public CiutatDTO obtenirCiutatPerId(Long id) {
        return ciutatRepository.findById(id)
                .map(CiutatDTO::new)
                .orElseThrow(() -> new RuntimeException("Ciutat no trobada"));
    }
}
```

- **CiutatController**
```java
@RestController
@RequestMapping("/api/ciutats")
public class CiutatController {
    @Autowired
    private CiutatService ciutatService;

    @GetMapping
    public List<CiutatDTO> obtenirTotes() {
        return ciutatService.obtenirTotesLesCiutats();
    }

    @GetMapping("/{id}")
    public CiutatDTO obtenirPerId(@PathVariable Long id) {
        return ciutatService.obtenirCiutatPerId(id);
    }
}
```

---

En definitiva:

- **Si volem una API simple:** Farem el `Controller` que cride directament el `Repository` (opci√≥ 1).  
- **Si volem modularitat i escalabilitat:** Separa en **Service + Repository** (opci√≥ 2).  
- **Si vols protegir la BD i evitar problemes:** Usa **DTOs** per encapsular les dades (opci√≥ 3).  

**Recomanaci√≥:** Per a un projecte seri√≥s i escalable, **Capa de Servei + DTOs** √©s la millor opci√≥.