---
title: 5.1.- Exercicis JPA. 
parent: 5.- Entitats JPA.

has_children: true
layout: default
nav_order: 10
---





# Exercicis JPA


### **1. Identifica les anotacions**

A partir del següent fragment, explica de forma clara i tècnica quina funció té cadascuna de les anotacions JPA utilitzades i com afecten la creació de la taula SQL:

```java
@Entity
@Table(name = "productes")
public class Producte {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 150)
    private String nom;

    @Column(unique = true)
    private String codi;
}
```

Explica el paper de: `@Entity`, `@Table`, `@Id`, `@GeneratedValue`, `@Column`.

---

### **2. Explica la diferència**

Explica les diferències següents, indicant quan s’ha d’emprar cada anotació o configuració:

* @OneToMany vs @ManyToOne
* FetchType.LAZY vs FetchType.EAGER
* CascadeType.ALL vs CascadeType.MERGE
* @Transient vs columna SQL normal

---

### **3. Crea l’entitat ALUMNE**

Crea l’entitat JPA que represente la taula següent:

```
ALUMNE(id PK, nom, cognoms, edat, foto BLOB)
```

Requisits: clau primària autogenerada, camp `nom` obligatori, `foto` com a BLOB.

---

### **4. Relació 1:N Departament – Empleat**

Modela les entitats i la relació següents:

* Un Departament té molts Empleats
* Un Empleat pertany a un Departament
* La col·lecció d’Empleats ha de ser LAZY
* En esborrar un Departament, també s’han d’esborrar els seus Empleats

Crea les dues entitats amb les anotacions necessàries.

---

### **5. Many-to-Many amb atribut extra**

Tenim les taules:

* ALUMNE
* CURS
* ALUMNE_CURS (conté també `data_matricula`)

Fes:

1. Explica per què aquest cas no es pot modelar amb un @ManyToMany simple.
2. Indica com seria la clau composta de la taula intermèdia.
3. Representa la relació en un esquema ASCII.

---

### **6. Evitar recursions JSON**

En el model:

```
Pais 1 → N Provincia
```

Indica tres maneres diferents d’evitar recursions infinites quan aquestes entitats s’exposen en una API REST que serialitza a JSON.

---

### **7. SQL generat**

Indica l’SQL equivalent que es generaria a la base de dades per al camp següent:

```java
@Column(name = "preu", precision = 10, scale = 2, nullable = false)
private BigDecimal preu;
```

---

### **8. Relació 1:1 Usuari – Perfil**

Donades les taules:

```
USUARI(id PK, nom, correu UNIQUE)
PERFIL(id PK, biografia, foto BLOB, usuari_id FK UNIQUE → USUARI.id)
```

Modela la relació 1:1 entre Usuari i Perfil:

* `usuari_id` és únic
* `foto` és un BLOB
* La relació ha d’estar expressada amb @OneToOne i @JoinColumn

Crea les dos entitats JPA.

---

### **9. Camps no persistits i BLOB**

Partint del model:

```
DOCUMENT(id PK, nom, contingut BLOB, tipus)
```

Crea una entitat JPA que:

* Tinga `contingut` com a @Lob
* Incloga un camp calculat o auxiliar que **no** persistisca en la base de dades (`@Transient`)
* Tinga `nom` com a NOT NULL

---

### **10. Cadena de relacions Client – Comanda – Línia**

Donades les taules:

```
CLIENT(id PK, nom)
COMANDA(id PK, data, client_id FK → CLIENT.id)
LINIA(id PK, producte, quantitat, comanda_id FK → COMANDA.id)
```

Crea les tres entitats i modela les relacions:

* Un Client té moltes Comandes
* Una Comanda té moltes Línies
* Una Línia pertany a una Comanda
* El camp `data` ha de ser LocalDate

---

### **11. Many-to-Many amb entitat pròpia (Usuari – Rol)**

Model relacional:

```
USUARI(id PK, nom, email UNIQUE, contrasenya)
ROL(id PK, nom UNIQUE)
USUARI_ROL(usuari_id FK, rol_id FK)
PRIMARY KEY (usuari_id, rol_id)
```

Tasques:

* Crea les entitats `Usuari`, `Rol` i `UsuariRol`
* Representa la relació ManyToMany a través d’una entitat intermèdia
* Utilitza una clau composta amb @Embeddable i @EmbeddedId
* Marca els camps únics (`email`, `nom`) segons el model

---
