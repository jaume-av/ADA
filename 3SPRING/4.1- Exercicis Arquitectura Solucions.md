
# **Activitat 1. Estructura d’un projecte Spring**

## **Enunciat**

Observa la següent estructura d’un projecte Spring Boot:

```text
com.exemple.demo
 ├─ controller
 ├─ service
 ├─ repository
 ├─ model
 └─ DemoApplication.java
```

1. Explica quina funció té cadascun dels paquets.
2. Indica quines relacions hi ha entre aquestes capes.
3. Explica quines accions no hauria de fer mai cada capa.

---

## **Solució comentada**

### Funció de cada paquet

* **controller**
  Conté els controladors que gestionen les peticions HTTP. Rep les sol·licituds del client, valida les dades bàsiques i delega la lògica en els serveis. No ha de contindre lògica de negoci.

* **service**
  Conté la lògica de negoci de l’aplicació. Aplica les regles del domini i decideix què fer amb les dades. Actua com a intermediari entre controlador i repositori.

* **repository**
  Conté l’accés a dades. S’encarrega de comunicar-se amb la base de dades i executar consultes. No ha de contindre lògica de negoci.

* **model**
  Conté les classes que representen les dades del domini (entitats, DTOs). Forma part del Model de l’arquitectura MVC.

* **DemoApplication.java**
  És el punt d’entrada de l’aplicació. Arranca Spring Boot i inicialitza el contenidor IoC.

### Relacions entre capes

La relació correcta és:

**Controller → Service → Repository → Base de dades**

Cada capa només ha de conéixer la immediatament inferior.

### Accions que no hauria de fer cada capa

* El controlador no ha d’accedir directament a la base de dades.
* El servei no ha de gestionar peticions HTTP.
* El repositori no ha de prendre decisions de negoci.

---

# **Activitat 2. Identificar el rol de cada classe**

## **Enunciat**

Es donen les següents classes:

* `UsuariController`
* `UsuariService`
* `UsuariRepository`
* `Usuari`

1. Indica quina anotació correspon a cada classe.
2. Explica per què no totes les classes porten la mateixa anotació.
3. Indica quines classes són beans de Spring.

---

## **Solució comentada**

### Anotacions

* `UsuariController` → `@RestController`
* `UsuariService` → `@Service`
* `UsuariRepository` → `@Repository` o `JpaRepository`
* `Usuari` → `@Entity` (si es persisteix) o classe model

### Per què no totes porten la mateixa anotació

Cada anotació indica una responsabilitat diferent dins de l’arquitectura. Tot i que totes deriven de `@Component`, el seu ús comunica clarament el rol de cada classe.

### Beans

Són beans:

* `UsuariController`
* `UsuariService`
* `UsuariRepository`

`Usuari` no sol ser un bean del contenidor IoC.

---

# **Activitat 3. Detecció d’errors d’arquitectura**

## **Enunciat**

Analitza el següent codi:

```java
@RestController
public class ProducteController {

    @Autowired
    private ProducteRepository repository;

    @GetMapping("/productes")
    public List<Producte> llistar() {
        return repository.findAll();
    }
}
```

1. Indica quin problema d’arquitectura presenta.
2. Quina capa falta?
3. Com hauria de ser l’estructura correcta?

---

## **Solució comentada**

### Problema

El controlador accedeix directament al repositori. Açò trenca la separació de responsabilitats i concentra massa lògica en el controlador.

### Capa que falta

Falta la capa **Service**, que hauria de contindre la lògica de negoci.

### Estructura correcta

* Controller → crida Service
* Service → crida Repository
* Repository → accedeix a dades

---

# **Activitat 4. De codi tradicional a IoC**

## **Enunciat**

```java
public class Servei {

    private Repositori repositori = new Repositori();

    public void executar() {
        repositori.guardar();
    }
}
```

1. Reescriu el codi utilitzant IoC i DI.
2. Indica les anotacions necessàries.
3. Explica la diferència conceptual.

---

## **Solució comentada**

### Reescriptura amb Spring

```java
@Repository
public class Repositori {
    public void guardar() { }
}

@Service
public class Servei {
    private final Repositori repositori;

    public Servei(Repositori repositori) {
        this.repositori = repositori;
    }

    public void executar() {
        repositori.guardar();
    }
}
```

### Anotacions

* `@Repository`
* `@Service`

### Diferència conceptual

La classe ja no crea la dependència. El contenidor IoC de Spring la crea i la injecta.

---

# **Activitat 5. Injecció per constructor**

## **Enunciat**

```java
@Service
public class CiutatService {

    private CiutatRepository repository;
}
```

Completa la classe perquè funcione amb DI i explica per què és recomanada.

---

## **Solució comentada**

```java
@Service
public class CiutatService {

    private final CiutatRepository repository;

    public CiutatService(CiutatRepository repository) {
        this.repository = repository;
    }
}
```

La injecció per constructor:

* fa explícites les dependències
* facilita proves
* evita errors d’inicialització

---

# **Activitat 6. Arquitectura MVC**

## **Enunciat**

1. Explica Model, Vista i Controlador.
2. Quina part no apareix clarament en una API REST?
3. Per què Spring separa responsabilitats?

---

## **Solució comentada**

* Model: dades i estructura del domini.
* Vista: presentació (HTML). En REST no és visible.
* Controlador: rep peticions i delega.

Spring separa responsabilitats per mantenibilitat, claredat i testabilitat.

---

# **Activitat 7. IoC i DI**

## **Enunciat**

1. Què és IoC?
2. Qui crea els objectes?
3. Per què no usar `new`?
4. Per què no injectar camps?

---

## **Solució comentada**

* IoC trasllada el control al contenidor.
* Spring crea els objectes.
* `new` trenca el contenidor.
* La injecció per camps dificulta proves i amaga dependències.

---

# **Activitat 8. Què passaria si…**

## **Enunciat**

1. Lleves `@Service`.
2. Uses `new` en un controlador.
3. Dos constructors sense `@Autowired`.

---

## **Solució comentada**

1. El bean no existeix → error d’arrencada.
2. L’objecte no està gestionat per Spring.
3. Spring no sap quin constructor usar → error.

---

# **Activitat 9. Flux d’una petició**

## **Enunciat**

Explica el recorregut d’una petició:

```
Client → Controller → Service → Repository → BD
```

---

## **Solució comentada**

El controlador rep la petició, el servei aplica la lògica, el repositori accedeix a dades. IoC crea els objectes i DI els connecta. El flux s’alinea amb MVC.

---

# **Activitat 10. Mini projecte: llibres i autors**

## **Enunciat**

Dissenya una aplicació Spring Boot per gestionar llibres i autors.

---

## **Solució comentada**

### Estructura

```text
controller
service
repository
model
```

### Classes

* Autor, Llibre
* AutorController, LlibreController
* AutorService, LlibreService
* AutorRepository, LlibreRepository

### Anotacions

* Controllers: `@RestController`
* Services: `@Service`
* Repositories: `JpaRepository`
* Models: `@Entity`

### Injecció

Controller → Service → Repository per constructor.

---
