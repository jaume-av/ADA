---
title:  Stream
parent: 1.- Gestió del Sistema de Fitxers
grand_parent: Persistència de Fitxers
has_children: true
layout: default
nav_order: 20
---



# Fluxos de Dades (Streams) en Java

---

## Introducció

Quan un programa necessita **comunicar-se amb l’exterior** (llegir un fitxer, escriure un informe, rebre dades d’Internet o enviar informació a la consola), necessita un **flux de dades (stream)**.

Un **flux** és un **camí seqüencial** pel qual les dades entren (entrada) o ixen (eixida) del programa.

**Passos bàsics en qualsevol flux:**

1. **Obrir** el flux (crear l’objecte adequat).
2. **Usar** el flux (llegir o escriure).
3. **Tancar** amb `close()` per alliberar recursos.

### Dos grans famílies de fluxos

| Família                 | Classe base                    | Unitat de treball           | Ús                                              |
| ----------------------- | ------------------------------ | --------------------------- | ----------------------------------------------- |
| **Fluxos de bytes**     | `InputStream` / `OutputStream` | Byte (8 bits)               | Dades binàries: imatges, vídeos, fitxers `.exe` |
| **Fluxos de caràcters** | `Reader` / `Writer`            | Caràcter (Unicode, 16 bits) | Textos humans: `.txt`, `.csv`, `.xml`           |

---

## Bones pràctiques generals

* **Tanca sempre els fluxos.** Usa `try-with-resources`, que els tanca automàticament:

  ```java
  try (FileInputStream fis = new FileInputStream("fitxer.bin")) {
      // ús
  } // es tanca sol encara que hi haja excepcions
  ```

* **Gestió d’excepcions habituals:**

  * `FileNotFoundException`: el fitxer no existeix o no tens permisos.
  * `EOFException`: lectura més enllà del final (sobretot amb `DataInputStream`).
  * `IOException`: errors generals d’entrada/eixida.

* **`flush()`**: només té sentit en escriptura; força a guardar el buffer al disc. Nota: `close()` ja fa `flush()`.

* **Ordre en fluxos encadenats:** si uses `new DataInputStream(new BufferedInputStream(...))`, tanques només el de fora (`dis.close()`), i tots els altres es tanquen automàticament.


---

# FLUXOS DE BYTES

*(Totes les classes deriven d’`InputStream` i `OutputStream`)*

Els fluxos de bytes treballen amb dades **binàries pures**. No interpreten res com a text.

Són ideals per a:

* Imatges, vídeos, PDF.
* Fitxers `.dat` amb dades primitives.
* Còpia d’arxius byte a byte.

---

## 1. Lectura binària (InputStream)

### 1.1 FileInputStream

**Finalitat:** llegir directament bytes d’un fitxer.

**Constructors habituals:**

* `FileInputStream(String path)`
* `FileInputStream(File file)`

**Mètodes detallats:**

* **`int read()`** → llig un byte del fitxer i el retorna com un enter entre 0 i 255. Retorna `-1` si s’ha arribat al final.
  *Ús*: quan volem processar dades byte a byte.
* **`int read(byte[] b)`** → intenta omplir l’array `b` amb bytes del fitxer i retorna quants n’ha llegit realment.
  *Ús*: més eficient que `read()` a soles, perquè fa menys crides al disc.
* **`int read(byte[] b, int off, int len)`** → igual que l’anterior, però ompli només una part de l’array, des de la posició `off` i fins `len` bytes.
* **`long skip(long n)`** → intenta saltar `n` bytes sense llegir-los. No sempre salta exactament els `n` bytes (retorna quants ha saltat).
* **`int available()`** → retorna quants bytes es poden llegir sense bloquejar (no és el total que queda en el fitxer!).
* **`void close()`** → tanca el flux i allibera el descriptor de fitxer.

**Quan triar-la:** per a lectures binàries senzilles.
**Quan evitar-la:** per a fitxers grans (millor `BufferedInputStream`).

**Exemple:** llegir i mostrar bytes.

```java
try (FileInputStream fis = new FileInputStream("logo.png")) {
    int b;
    while ((b = fis.read()) != -1) {      // llegim byte a byte
        System.out.println(b);            // mostrem el valor
    }
}
```

**Explicació de l’exemple:**

1. `new FileInputStream("logo.png")` → obrim el fitxer `logo.png` en mode lectura binària.
2. `int b;` → declarem una variable per guardar cada byte llegit.
3. `while ((b = fis.read()) != -1)` → bucle que llig byte a byte fins al final del fitxer (`-1`).
4. `System.out.println(b);` → mostra cada byte com un número enter (0–255).
5. `try-with-resources` → tanca automàticament `fis` al final, encara que hi haja errors.

---

### 1.2 BufferedInputStream

**Finalitat:** millorar la velocitat de lectura amb un buffer intern.

**Constructor:**

* `BufferedInputStream(InputStream in)`

**Mètodes detallats:**

* **`int read()` / `int read(byte[] b)`** → funcionen com a `FileInputStream`, però llegint d’un **buffer en memòria** que redueix l’accés al disc.
* **`void mark(int readlimit)`** → marca la posició actual en el flux. Es pot tornar a ella després amb `reset()`. El paràmetre `readlimit` indica quants bytes podem llegir abans de perdre la marca.
* **`void reset()`** → torna a la posició marcada amb `mark()`.
* **`boolean markSupported()`** → diu si el flux suporta `mark/reset`. En `BufferedInputStream` és `true`.
* **`void close()`** → tanca el flux i buida el buffer intern.

**Quan triar-la:** fitxers grans, lectures repetides.
**Quan evitar-la:** fitxers menuts.

**Exemple:** llegir amb buffer.

```java
try (BufferedInputStream bis =
         new BufferedInputStream(new FileInputStream("video.mp4"))) {
    byte[] buf = new byte[4096];
    int n;
    while ((n = bis.read(buf)) != -1) {
        System.out.println("Llegits " + n + " bytes");
    }
}
```

**Explicació de l’exemple:**

1. `new FileInputStream("video.mp4")` → obrim el fitxer de vídeo en mode lectura.
2. `new BufferedInputStream(...)` → emboliquem el flux amb un buffer de memòria.
3. `byte[] buf = new byte[4096];` → creem un array de 4 KB per llegir blocs sencers.
4. `bis.read(buf)` → llig fins a 4096 bytes en cada iteració; retorna el nombre real llegit.
5. `while ((n = bis.read(buf)) != -1)` → bucle que continua fins al final.
6. `System.out.println("Llegits " + n + " bytes");` → mostra quants bytes s’han llegit cada volta.

---

### 1.3 DataInputStream

**Finalitat:** llegir dades primitives (int, double, String) en format binari.

**Constructor:**

* `DataInputStream(InputStream in)`

**Mètodes detallats:**

* **`boolean readBoolean()`**, **`byte readByte()`**, **`char readChar()`**, **`short readShort()`**, **`int readInt()`**, **`long readLong()`**, **`float readFloat()`**, **`double readDouble()`** → lligen primitives en el mateix format binari en què es van escriure amb `DataOutputStream`.
* **`String readUTF()`** → llig una cadena codificada en *Modified UTF-8*. Només funciona correctament si es va escriure amb `writeUTF()`.
* **`void close()`** → tanca el flux.

**Important**: l’ordre de lectura ha de coincidir exactament amb l’ordre d’escriptura.

**Quan triar-la:** per a fitxers `.dat` amb registres.
**Quan evitar-la:** quan no controles l’ordre d’escriptura.

**Exemple:** llegir alumnes.

```java
try (DataInputStream dis = new DataInputStream(
         new BufferedInputStream(new FileInputStream("notes.dat")))) {
    int n = dis.readInt();
    for (int i = 0; i < n; i++) {
        long id = dis.readLong();
        String nom = dis.readUTF();
        double nota = dis.readDouble();
        System.out.printf("%d %s %.2f%n", id, nom, nota);
    }
}
```

**Explicació de l’exemple:**

1. Obrim el fitxer `notes.dat` amb `FileInputStream`.
2. L’emboliquem amb `BufferedInputStream` per fer-lo més ràpid.
3. L’emboliquem amb `DataInputStream` per poder llegir primitives.
4. `dis.readInt()` → llegim el nombre de registres guardats.
5. Recorrem amb un bucle:

   * `readLong()` → llegim un identificador.
   * `readUTF()` → llegim un nom.
   * `readDouble()` → llegim una nota.
6. `System.out.printf(...)` → mostrem els valors amb format.
7. Tancament automàtic amb `try-with-resources`.

---

## 2. Escriptura binària (OutputStream)

### 2.1 FileOutputStream

**Finalitat:** escriure bytes en un fitxer.

**Constructors habituals:**

* `FileOutputStream(String path)` → sobreescriu.
* `FileOutputStream(String path, boolean append)` → si true, afegeix.

**Mètodes detallats:**

* **`void write(int b)`** → escriu un byte. Només els 8 bits baixos del valor de l’enter es guarden.
* **`void write(byte[] b)`** → escriu tot l’array de bytes `b`.
* **`void write(byte[] b, int off, int len)`** → escriu només una part de l’array, des de la posició `off` i durant `len` bytes.
* **`void flush()`** → força a guardar les dades escrites al sistema de fitxers immediatament.
* **`void close()`** → tanca el flux i allibera recursos. Ja fa un `flush()` automàtic.

**Quan triar-la:** dades simples.
**Quan evitar-la:** sense buffer en fitxers grans.

**Exemple:** escriure bytes.

```java
try (FileOutputStream fos = new FileOutputStream("dades.bin")) {
    fos.write(new byte[]{10,20,30});
}
```

**Explicació de l’exemple:**

1. `new FileOutputStream("dades.bin")` → crea (o sobreescriu) el fitxer binari.
2. `fos.write(new byte[]{10,20,30});` → escriu tres bytes amb valors 10, 20 i 30.
3. `try-with-resources` → es tanca automàticament el flux.

---

### 2.2 BufferedOutputStream

**Finalitat:** millorar l’eficiència amb buffer.

**Constructor:**

* `BufferedOutputStream(OutputStream out)`

**Mètodes detallats:**

* **`void write(int b)` / `void write(byte[] b)` / `void write(byte[] b, int off, int len)`** → escriuen dades en el buffer intern i les guarden al disc només quan el buffer està ple o es crida `flush()`.
* **`void flush()`** → obliga a escriure totes les dades que queden al buffer encara que no estiga ple.
* **`void close()`** → tanca el flux i escriu qualsevol dada pendent.

**Exemple:** escriure bloc gran.

```java
try (BufferedOutputStream bos =
         new BufferedOutputStream(new FileOutputStream("gran_sortida.bin"))) {
    byte[] bloc = new byte[8192];
    bos.write(bloc);
}
```

**Explicació de l’exemple:**

1. `new FileOutputStream("gran_sortida.bin")` → obrim un fitxer per escriure.
2. `new BufferedOutputStream(...)` → afegim un buffer per agrupar l’escriptura.
3. `new byte[8192]` → creem un bloc de 8 KB inicialitzat a zeros.
4. `bos.write(bloc);` → escriu tot el bloc en memòria i després l’envia al fitxer.

---

### 2.3 DataOutputStream

**Finalitat:** escriure primitives en binari.

**Constructor:**

* `DataOutputStream(OutputStream out)`

**Mètodes detallats:**

* **`void writeBoolean(boolean v)`, `writeByte(byte v)`, `writeChar(char v)`, `writeShort(short v)`, `writeInt(int v)`, `writeLong(long v)`, `writeFloat(float v)`, `writeDouble(double v)`** → escriuen valors primitius en binari.
* **`void writeUTF(String s)`** → escriu una cadena en format *Modified UTF-8*. Ha de ser llegida amb `readUTF()`.
* **`void flush()`** → força a escriure el buffer immediatament.
* **`void close()`** → tanca el flux.

**Important**: cal respectar sempre l’ordre i el tipus de dades quan després es llig amb `DataInputStream`.

**Quan triar-la:** guardar registres binaris.
**Quan evitar-la:** si necessites compatibilitat amb altres llenguatges.

**Exemple:** guardar alumnes.

```java
try (DataOutputStream dos = new DataOutputStream(
         new BufferedOutputStream(new FileOutputStream("notes.dat")))) {
    dos.writeInt(2);
    dos.writeLong(1L); dos.writeUTF("Anna"); dos.writeDouble(9.5);
    dos.writeLong(2L); dos.writeUTF("Marc"); dos.writeDouble(7.8);
}
```

**Explicació de l’exemple:**

1. Obrim el fitxer `notes.dat` amb `FileOutputStream`.
2. L’emboliquem amb `BufferedOutputStream` per fer-lo més eficient.
3. L’emboliquem amb `DataOutputStream` per poder escriure primitives.
4. `dos.writeInt(2);` → indiquem que hi haurà 2 registres.
5. Primer registre: `writeLong(1L)`, `writeUTF("Anna")`, `writeDouble(9.5)`.
6. Segon registre: `writeLong(2L)`, `writeUTF("Marc")`, `writeDouble(7.8)`.
7. `try-with-resources` → es tanca automàticament.

---

# FLUXOS DE CARÀCTERS

*(Totes les classes deriven de `Reader` i `Writer`)*

Els fluxos de caràcters interpreten els bytes com a **text**, segons un **charset** (UTF-8, ISO...).

Són ideals per a:

* Fitxers `.txt`, `.csv`, `.xml`, `.json`.
* Qualsevol informació llegible per humans.

---

## Nota sobre FileReader/FileWriter

Aquestes classes usen **charset del sistema** → pot fallar amb accents.

**Pitjor pràctica:**

```java
FileReader fr = new FileReader("entrada.txt"); // depén del sistema
```

**Millor pràctica:**

```java
new InputStreamReader(new FileInputStream("entrada.txt"), StandardCharsets.UTF_8);
```

---

## 1. Lectura de text (Reader)

### 1.1 FileReader

**Finalitat:** llegir caràcters amb charset del sistema.

**Mètodes detallats:**

* **`int read()`** → llig un caràcter i el retorna com a enter Unicode. Retorna `-1` si arriba al final.
* **`int read(char[] cbuf)`** → llig diversos caràcters i els guarda en l’array. Retorna quants n’ha llegit.
* **`int read(char[] cbuf, int off, int len)`** → com l’anterior però en una porció de l’array.
* **`boolean ready()`** → diu si hi ha caràcters disponibles per llegir sense bloquejar.
* **`void close()`** → tanca el flux.

Usa el **charset del sistema**, pot donar problemes amb accents.

**Exemple:**

```java
try (FileReader fr = new FileReader("poema.txt")) {
    char[] buf = new char[256];
    int n;
    while ((n = fr.read(buf)) != -1) {
        System.out.print(new String(buf, 0, n));
    }
}
```

**Explicació de l’exemple:**

1. `new FileReader("poema.txt")` → obrim el fitxer en mode lectura de caràcters.
2. `char[] buf = new char[256];` → reservem un buffer de 256 caràcters.
3. `fr.read(buf)` → ompli el buffer amb caràcters llegits i retorna quants n’ha llegit.
4. `while ((n = fr.read(buf)) != -1)` → bucle que continua fins al final.
5. `System.out.print(new String(buf, 0, n))` → construïm una cadena amb els caràcters llegits i la mostrem.
6. `try-with-resources` → tanca automàticament el flux.

---

### 1.2 BufferedReader

**Finalitat:** llegir línies amb `readLine()`.

**Mètodes detallats:**

* **`String readLine()`** → llig una línia sencera (sense incloure el salt de línia). Retorna `null` si arriba al final.
* **`int read()` / `int read(char[] cbuf)`** → llig caràcters de manera més eficient gràcies al buffer.
* **`void mark(int readAheadLimit)`** → marca la posició actual, permetent tornar-hi amb `reset()`.
* **`void reset()`** → torna a la posició marcada.
* **`boolean markSupported()`** → retorna `true`.
* **`void close()`** → tanca el flux.

**Exemple:**

```java
try (BufferedReader br = new BufferedReader(new FileReader("entrada.txt"))) {
    String linia;
    while ((linia = br.readLine()) != null) {
        System.out.println(linia);
    }
}
```

**Explicació de l’exemple:**

1. `new FileReader("entrada.txt")` → obrim el fitxer en mode lectura.
2. `new BufferedReader(...)` → afegim un buffer per optimitzar i permetre `readLine()`.
3. `br.readLine()` → retorna una línia completa o `null` si ja no hi ha més.
4. `while ((linia = br.readLine()) != null)` → bucle fins al final.
5. `System.out.println(linia);` → mostra cada línia per consola.
6. El flux es tanca automàticament al final.

---

### 1.3 InputStreamReader

**Finalitat:** convertir bytes a caràcters amb charset.

**Mètodes detallats:**

* **`int read()` / `int read(char[] cbuf)`** → converteix bytes d’un `InputStream` en caràcters segons el charset especificat.
* **`boolean ready()`** → diu si hi ha caràcters disponibles per llegir.
* **`String getEncoding()`** → retorna el nom del charset usat.
* **`void close()`** → tanca el flux.

**Exemple:**

```java
try (BufferedReader br = new BufferedReader(
         new InputStreamReader(new FileInputStream("text_utf8.txt"), StandardCharsets.UTF_8))) {
    String linia;
    while ((linia = br.readLine()) != null) {
        System.out.println(linia);
    }
}
```

**Explicació de l’exemple:**

1. `new FileInputStream("text_utf8.txt")` → obrim el fitxer en mode binari.
2. `new InputStreamReader(..., StandardCharsets.UTF_8)` → convertim bytes a caràcters amb el charset UTF-8.
3. `new BufferedReader(...)` → afegim la lectura per línies amb buffer.
4. `br.readLine()` → llig línies de text en UTF-8 correctament.
5. `while (...)` → recorrem fins al final.
6. `System.out.println(linia)` → mostrem el text.

---

## 2. Escriptura de text (Writer)

### 2.1 FileWriter

**Finalitat:** escriure caràcters amb charset del sistema.

**Mètodes detallats:**

* **`void write(String s)`** → escriu una cadena completa en el fitxer.
* **`void write(char[] cbuf, int off, int len)`** → escriu només part d’un array de caràcters.
* **`void flush()`** → força a escriure les dades pendents al fitxer.
* **`void close()`** → tanca el flux i aboca les dades restants.

Usa el **charset del sistema** per defecte.

**Exemple:**

```java
try (FileWriter fw = new FileWriter("nota.txt")) {
    fw.write("Hola món");
}
```

**Explicació de l’exemple:**

1. `new FileWriter("nota.txt")` → crea o sobreescriu el fitxer en mode text.
2. `fw.write("Hola món")` → escriu la cadena.
3. El fitxer es tanca automàticament i es guarden les dades.

---

### 2.2 BufferedWriter

**Finalitat:** escriure línies.

**Mètodes detallats:**

* **`void write(String s)` / `write(char[] cbuf, int off, int len)`** → escriuen text de forma més eficient gràcies al buffer.
* **`void newLine()`** → escriu un salt de línia segons el sistema operatiu (portàtil, millor que `\n`).
* **`void flush()`** → força a escriure les dades que hi ha al buffer.
* **`void close()`** → tanca el flux.

**Exemple:**

```java
try (BufferedWriter bw = new BufferedWriter(new FileWriter("sortida.txt"))) {
    bw.write("Primera línia");
    bw.newLine();
    bw.write("Segona línia");
}
```

**Explicació de l’exemple:**

1. `new FileWriter("sortida.txt")` → obrim fitxer de text.
2. `new BufferedWriter(...)` → millorem l’eficiència d’escriptura.
3. `bw.write("Primera línia")` → escriu text.
4. `bw.newLine()` → inserix salt de línia.
5. `bw.write("Segona línia")` → escriu més text.
6. Al tancar-se, s’escriu tot al disc.

---

### 2.3 OutputStreamWriter

**Finalitat:** escriure text amb charset concret.

**Mètodes detallats:**

* **`void write(String s)` / `write(char[] cbuf, int off, int len)`** → escriu caràcters convertint-los a bytes segons el charset indicat.
* **`String getEncoding()`** → retorna el charset realment en ús.
* **`void flush()`** → força a escriure dades pendents.
* **`void close()`** → tanca el flux.

**Exemple:**

```java
try (OutputStreamWriter osw =
         new OutputStreamWriter(new FileOutputStream("resum.txt"), StandardCharsets.UTF_8)) {
    osw.write("Accents i caràcters: informació, valència");
}
```

**Explicació de l’exemple:**

1. `new FileOutputStream("resum.txt")` → crea el fitxer en mode binari.
2. `new OutputStreamWriter(..., UTF_8)` → converteix caràcters a bytes amb codificació UTF-8.
3. `osw.write(...)` → escriu la cadena amb accents.
4. El tancament guarda les dades al disc.

---

### 2.4 PrintWriter

**Finalitat:** escriure amb format.

**Mètodes detallats:**

* **`void print(String s)`** → escriu un text sense salt de línia.
* **`void println(String s)`** → escriu text i després un salt de línia.
* **`PrintWriter printf(String fmt, Object... args)` / `format(...)`** → escriu text amb format (semblant a `printf` de C).
* **`boolean checkError()`** → comprova si ha passat algun error d’escriptura.
* **`void flush()`** → força l’escriptura immediata.
* **`void close()`** → tanca el flux.
* *(Constructor amb `autoFlush=true`)* → fa que cada `println()` o `printf()` aboque automàticament.

**Exemple:**

```java
try (PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter("informe.txt")))) {
    pw.println("ID\tNom\tNota");
    pw.printf("%d\t%s\t%.2f%n", 1, "Anna", 9.25);
}
```

**Explicació de l’exemple:**

1. Obrim `informe.txt` amb `FileWriter`.
2. L’emboliquem amb `BufferedWriter` i `PrintWriter`.
3. `pw.println(...)` → escriu la capçalera.
4. `pw.printf(...)` → escriu un registre amb format.
5. Al tancar, es guarden les dades.

---

## 3. Combinacions habituals (text) amb exemples

**Lectura simple:**

```java
try (BufferedReader br = new BufferedReader(new FileReader("entrada.txt"))) {
    String linia;
    while ((linia = br.readLine()) != null) {
        System.out.println(linia);
    }
}
```

**Explicació:**

1. `FileReader` → lectura de text.
2. `BufferedReader` → permet `readLine()`.
3. Llegim línies fins a `null`.

---

**Lectura amb charset:**

```java
try (BufferedReader br = new BufferedReader(
         new InputStreamReader(new FileInputStream("entrada.txt"), StandardCharsets.UTF_8))) {
    String linia;
    while ((linia = br.readLine()) != null) {
        System.out.println(linia);
    }
}
```

**Explicació:**

1. `FileInputStream` → obri el fitxer en bytes.
2. `InputStreamReader(..., UTF-8)` → converteix a caràcters.
3. `BufferedReader` → lectura per línies.

---

**Escriptura simple:**

```java
try (BufferedWriter bw = new BufferedWriter(new FileWriter("sortida.txt"))) {
    bw.write("Primera línia");
    bw.newLine();
    bw.write("Segona línia");
}
```

**Explicació:**

1. `FileWriter` → crea un fitxer de text.
2. `BufferedWriter` → millora eficiència i permet `newLine()`.
3. Escrivim dues línies.

---

**Escriptura amb charset:**

```java
try (BufferedWriter bw = new BufferedWriter(
         new OutputStreamWriter(new FileOutputStream("sortida_utf8.txt"), StandardCharsets.UTF_8))) {
    bw.write("Accents: àèíòú ç ñ");
}
```

**Explicació:**

1. `FileOutputStream` → crea fitxer en bytes.
2. `OutputStreamWriter(..., UTF-8)` → converteix caràcters a UTF-8.
3. `BufferedWriter` → escriu text eficientment.

---

**Escriptura amb format:**

```java
try (PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter("informe.txt")))) {
    pw.printf("%d\t%s\t%.2f%n", 1, "Anna", 9.25);
    pw.printf("%d\t%s\t%.2f%n", 2, "Marc", 7.80);
}
```

**Explicació:**

1. Obrim fitxer de text amb `FileWriter`.
2. Afegim `BufferedWriter` i `PrintWriter`.
3. `printf` → imprimeix línies amb format i decimals.

---

# Streams estàndard

**`System.in`** → entrada de consola (`InputStream`).
Exemple:

```java
try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {
    System.out.print("Introdueix el teu nom: ");
    String nom = br.readLine();
    System.out.println("Hola " + nom);
}
```

**Explicació:**

1. `System.in` → entrada de consola en bytes.
2. `InputStreamReader(..., UTF-8)` → converteix a caràcters.
3. `BufferedReader` → llegim una línia.
4. Mostrem un missatge personalitzat.

---

**`System.out`** → sortida consola (`PrintStream`), amb `print`, `println`, `printf`.

**`System.err`** → errors de consola.
Exemple:

```java
System.err.println("Error: fitxer no trobat");
```

**Explicació:**

1. `System.err` → canal separat per a errors.
2. Mostra un missatge independent de l’eixida normal (`System.out`).

---

# En resum

* **Fluxos de bytes** (`InputStream`/`OutputStream`) → dades binàries.
* **Fluxos de caràcters** (`Reader`/`Writer`) → text.
* **Buffered**\* → rendiment.
* **Data\*Stream** → primitives binàries.
* **StreamReader/Writer** → control de charset.
* **PrintWriter** → text amb format.
* **try-with-resources** i **gestió d’excepcions** → bones pràctiques.

