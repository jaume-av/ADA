---
title: 2.4.- Jackson. Serialitzant - Deserialitzat.
parent: 2.- Gesti√≥ del Contingut
grand_parent: Persist√®ncia de Fitxers
has_children: true
layout: default
nav_order: 40
---




# Mapejant amb Jackson 

(Serialitzaci√≥ i Deserialitzaci√≥ JSON i XML)


Recorda que:

| Proc√©s              | Descripci√≥                            | Exemple                                |
| ------------------- | ------------------------------------- | -------------------------------------- |
| **Serialitzaci√≥**   | Convertir un objecte Java en JSON/XML | `mapper.writeValueAsString(obj)`       |
| **Deserialitzaci√≥** | Convertir JSON/XML en un objecte Java | `mapper.readValue(json, Classe.class)` |


Per a **mapejar** dades estructurades (JSON o XML) a **classes Java (POJOs/DTOs)**. Jackson ens ofereix un **nucli com√∫** d‚Äôanotacions i configuraci√≥ que serveix tant per a JSON com per a XML, i un **conjunt redu√Øt d‚Äôanotacions espec√≠fiques d‚ÄôXML** per a casos concrets (atributs, wrapper de llistes, etc.)

Per tant, es poden **reutilitzar les mateixes classes** per als dos formats i nom√©s afegir ajustos d‚ÄôXML quan calga.

---


##  Serialitzaci√≥ (Java ‚Üí JSON/XML) amb Jackson

L‚Äôobjectiu √©s convertir **objectes Java** (POJOs/DTOs) a **text**: JSON o XML.
La pe√ßa clau √©s:

* **JSON** ‚Üí `ObjectMapper` (m√≤dul jackson-databind)
* **XML** ‚Üí `XmlMapper` (m√≤dul jackson-dataformat-xml)

### M√®todes essencials (i qu√® retornen)

> No memoritzem, **entenguem**: ‚Äúwrite‚Äù escriu (serialitza), ‚Äúread‚Äù llig (deserialitza). Les versions ‚ÄúAsString‚Äù retornen una **String**; les que no, escriuen a **fitxer** o **flux**.

### Per a JSON (`ObjectMapper`)

| Retorn         | M√®tode                                       | Qu√® fa                                                                                                                |
| -------------- | -------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| `String`       | `writeValueAsString(Object value)`           | Converteix l‚Äôobjecte a **JSON** en una `String`.                                                                      |
| `void`         | `writeValue(File file, Object value)`        | Escriu l‚Äôobjecte com a **JSON** dins d‚Äôun fitxer.                                                                     |
| `void`         | `writeValue(OutputStream out, Object value)` | Escriu el **JSON** cap a un **Stream** (ex: `FileOutputStream`).                                                      |
| `ObjectWriter` | `writerWithDefaultPrettyPrinter()`           | Prepara un **escriptor** que indenta/formateta l‚Äôeixida. (S‚Äôusa amb `.writeValueAsString(...)` o `.writeValue(...)`.) |

### Per a XML (`XmlMapper`)

√âs el mateix patr√≥, per√≤ amb XML:

| Retorn   | M√®tode                                       | Qu√® fa                                           |
| -------- | -------------------------------------------- | ------------------------------------------------ |
| `String` | `writeValueAsString(Object value)`           | Converteix l‚Äôobjecte a **XML** en una `String`.  |
| `void`   | `writeValue(File file, Object value)`        | Escriu l‚Äôobjecte com a **XML** dins d‚Äôun fitxer. |
| `void`   | `writeValue(OutputStream out, Object value)` | Escriu l‚Äô**XML** cap a un **Stream**.            |

> **Truc did√†ctic:** per a **JSON**, sempre `new ObjectMapper()`. Per a **XML**, sempre `new XmlMapper()`.

### Configuraci√≥ b√†sica (dates, pretty-print, etc.)

* **Indentaci√≥**: `mapper.enable(SerializationFeature.INDENT_OUTPUT)` **o** `mapper.writerWithDefaultPrettyPrinter()...`
* **Dates modernes (Java Time API)**: registra `JavaTimeModule` i desactiva timestamps.

```java
// JSON
ObjectMapper json = new ObjectMapper()
        .registerModule(new JavaTimeModule()) // LocalDate, LocalDateTime, ...
        .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS) // 2025-10-13 en lloc de n√∫mero
        .enable(SerializationFeature.INDENT_OUTPUT); // format identat

// XML
XmlMapper xml = (XmlMapper) new XmlMapper()
        .registerModule(new JavaTimeModule())
        .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
        .enable(SerializationFeature.INDENT_OUTPUT);
```

> **Per qu√®?** Sense `JavaTimeModule`, `LocalDate` dona problemes o ix com a timestamp.
> Amb `INDENT_OUTPUT`, l‚Äôeixida √©s llegible per a classe i ex√†mens.

## Exemple complet JSON i XML

Partim de la classe java senzilla (o POJO):



```java
// Producte.java
// POJO sense anotacions. Constructors buits i getters/setters perqu√® Jackson puga accedir.
public class Producte {
    private String nom;
    private double preu;
    private boolean actiu;

    public Producte() {} // Obligatori per a Jackson (constructor per defecte)

    public Producte(String nom, double preu, boolean actiu) {
        this.nom = nom;
        this.preu = preu;
        this.actiu = actiu;
    }

    public String getNom() { return nom; }
    public void setNom(String nom) { this.nom = nom; }

    public double getPreu() { return preu; }
    public void setPreu(double preu) { this.preu = preu; }

    public boolean isActiu() { return actiu; } // per a booleans, isXxx √©s OK
    public void setActiu(boolean actiu) { this.actiu = actiu; }
}
```

### Serialitzar a **JSON** (String i Fitxer)

En aquest exemple, serialitzem un objecte `Producte` a JSON, primer com a `String` i despr√©s a un fitxer.

```java
// SerialitzaJSON.java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import java.io.File;

public class SerialitzaJSON {
    public static void main(String[] args) throws Exception {
        // 1) Creem dades Java
        Producte p = new Producte("Ratol√≠ Gamer", 24.99, true);

        // 2) Configurem l'ObjectMapper
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        mapper.enable(SerializationFeature.INDENT_OUTPUT);

        // 3) Obtenir JSON com a String (per a mostrar per consola/log)
        String json = mapper.writeValueAsString(p); // <-- No toca disc, nom√©s genera una String
        System.out.println("JSON en String:");
        System.out.println(json);

        // 4) Escriure JSON a fitxer (src/main/resources √©s bona ubicaci√≥ per a dades)
        File out = new File("src/main/resources/producte.json");
        mapper.writeValue(out, p); // <-- Ara s√≠, a disc
        System.out.println("S'ha guardat a: " + out.getAbsolutePath());
    }
}
```
L'eixida per consola ser√†:

```json
{
  "nom" : "Ratol√≠ Gamer",
  "preu" : 24.99,
  "actiu" : true
}
```


### Serialitzar a **XML** (String i Fitxer)

```java
// SerialitzaXML.java
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;
import java.io.File;

public class SerialitzaXML {
    public static void main(String[] args) throws Exception {
        Producte p = new Producte("Ratol√≠ Gamer", 24.99, true);

        XmlMapper xml = new XmlMapper();
        xml.registerModule(new JavaTimeModule());
        xml.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        xml.enable(SerializationFeature.INDENT_OUTPUT);
        // Opcional: afegir la cap√ßalera XML <?xml ...?>
        xml.configure(ToXmlGenerator.Feature.WRITE_XML_DECLARATION, true);

        String xmlString = xml.writeValueAsString(p);
        System.out.println("XML en String:");
        System.out.println(xmlString);

        File out = new File("src/main/resources/producte.xml");
        xml.writeValue(out, p);
        System.out.println("S'ha guardat a: " + out.getAbsolutePath());
    }
}
```

L'eixida per consola ser√†:

```xml
<?xml version='1.0' encoding='UTF-8'?>
<Producte>
  <nom>Ratol√≠ Gamer</nom>
  <preu>24.99</preu>
  <actiu>true</actiu>
</Producte>
```


> **Nota XML**: Com que no hem posat anotacions d‚ÄôXML, Jackson deriva noms d‚Äôetiqueta dels **noms de camp**.
> Si despr√©s vols `<nom_producte>` en lloc de `<nom>`, tindrem que posar **anotacions XML**.

## Serialitzar llistes i objectes anidats

```java
// Cataleg.java
import java.util.List;

public class Cataleg {
    private String nom;
    private List<Producte> productes;

    public Cataleg() {}
    public Cataleg(String nom, List<Producte> productes) {
        this.nom = nom;
        this.productes = productes;
    }
    public String getNom() { return nom; }
    public void setNom(String nom) { this.nom = nom; }
    public List<Producte> getProductes() { return productes; }
    public void setProductes(List<Producte> productes) { this.productes = productes; }
}
```

```java
// SerialitzaColleccions.java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.util.List;
import java.io.File;

public class SerialitzaColleccions {
    public static void main(String[] args) throws Exception {
        Cataleg cat = new Cataleg(
            "Perif√®rics",
            List.of(
                new Producte("Ratol√≠ Gamer", 24.99, true),
                new Producte("Teclat Mec√†nic", 59.90, true)
            )
        );

        ObjectMapper om = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
        // A String
        System.out.println(om.writeValueAsString(cat));
        // A fitxer
        om.writeValue(new File("src/main/resources/cataleg.json"), cat);
    }
}
```

El resultat JSON ser√†:

```json
{
  "nom" : "Perif√®rics",
  "productes" : [ {
    "nom" : "Ratol√≠ Gamer",
    "preu" : 24.99,
    "actiu" : true
  }, {
    "nom" : "Teclat Mec√†nic",
    "preu" : 59.9,
    "actiu" : true
  } ]
}
```


La versi√≥ amb `XmlMapper` √©s id√®ntica, nom√©s canviant la classe i el nom del fitxer.

* **Es a dir, canviem `ObjectMapper` per `XmlMapper` i `cataleg.json` per `cataleg.xml`.**

i l'eixida ser√†:

```xml
<?xml version='1.0' encoding='UTF-8'?>
<Cataleg>
  <nom>Perif√®rics</nom>
  <productes>
    <productes>
      <nom>Ratol√≠ Gamer</nom>
      <preu>24.99</preu>
      <actiu>true</actiu>
    </productes>
    <productes>
      <nom>Teclat Mec√†nic</nom>
      <preu>59.9</preu>
      <actiu>true</actiu>
    </productes>
  </productes>
</Cataleg>
```


---

##  Deserialitzaci√≥ (JSON/XML ‚Üí Java)

Ara fem el cam√≠ contrari: **a partir d‚Äôun text** (JSON o XML) o un **fitxer**, Jackson crea **objectes Java**.

### M√®todes de lectura

* **JSON (`ObjectMapper`)**

| Retorn     | M√®tode                                          | Qu√® fa                                                                |
| ---------- | ----------------------------------------------- | --------------------------------------------------------------------- |
| `<T>`      | `readValue(String content, Class<T> valueType)` | Converteix una **String JSON** a un objecte Java.                     |
| `<T>`      | `readValue(File src, Class<T> valueType)`       | Converteix un **fitxer JSON** a un objecte Java.                      |
| `JsonNode` | `readTree(String/Reader/File/InputStream)`      | Llig el JSON com a **arbre** (quan no tens POJO o vols inspeccionar). |

* **XML (`XmlMapper`)**

Exactament igual, per√≤ amb `XmlMapper`.

### Deserialitzar JSON (String i Fitxer)

En este exemple partime del string JSON i d‚Äôun fitxer `producte.json`:

``` java 
String json = """ 
{ "nom": "Raton Gamer", "preu": 24.99, "actiu": true } 
""";

El fitxer `producte.json` hauria de tenir el format:

```json
{
  "nom": "Raton Gamer",
  "preu": 24.99,
  "actiu": true
}
```

```java
// DeserialitzaJSON.java
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.File;

public class DeserialitzaJSON {
    public static void main(String[] args) throws Exception {
        ObjectMapper om = new ObjectMapper();

        // 1) Des de String
        String json = """
          { "nom": "Raton Gamer", "preu": 24.99, "actiu": true }
        """;
        Producte p = om.readValue(json, Producte.class);
        System.out.println("Nom: " + p.getNom() + ", preu: " + p.getPreu());

        // 2) Des de Fitxer
        File f = new File("src/main/resources/producte.json");
        if (f.exists()) {
            Producte p2 = om.readValue(f, Producte.class);
            System.out.println("Des de fitxer ‚Üí " + p2.getNom());
        } else {
            System.err.println("No trobe el fitxer producte.json");
        }
    }
}
```

 

### Deserialitzar XML (String i Fitxer)

```java
// DeserialitzaXML.java
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import java.io.File;

public class DeserialitzaXML {
    public static void main(String[] args) throws Exception {
        XmlMapper xml = new XmlMapper();

        String xmlString = """
          <Producte>
            <nom>Raton Gamer</nom>
            <preu>24.99</preu>
            <actiu>true</actiu>
          </Producte>
        """;

        Producte p = xml.readValue(xmlString, Producte.class);
        System.out.println("Nom: " + p.getNom() + ", actiu: " + p.isActiu());

        File f = new File("src/main/resources/producte.xml");
        if (f.exists()) {
            Producte p2 = xml.readValue(f, Producte.class);
            System.out.println("Des de fitxer ‚Üí " + p2.getNom());
        }
    }
}
```

El fitxer `producte.xml` hauria de tenir el format:

```xml
<Producte>
  <nom>Raton Gamer</nom>
  <preu>24.99</preu>
  <actiu>true</actiu>
</Producte>
``` 


### Quan **no tens POJOs** o el JSON √©s ‚Äúlliure‚Äù: `JsonNode`

Quan no disposem d‚Äôun model fix (POJOs) o nom√©s volem llegir camps concrets d‚Äôun JSON desconegut, podem usar l‚ÄôAPI d‚Äôarbre de Jackson (**JsonNode**).

>En aquest curs treballarem amb POJOs i anotacions, per tant, sols saber que existeix.

```java
// Llegir sense classe, recorrent l'arbre
import com.fasterxml.jackson.databind.*;

public class LlegirComArbre {
    public static void main(String[] args) throws Exception {
        String json = """
          { "ciutat":"Madrid", "temperatures":[19,21,18,23,20] }
        """;
        ObjectMapper om = new ObjectMapper();
        JsonNode root = om.readTree(json); // Arrel de l‚Äôarbre

        String ciutat = root.get("ciutat").asText();
        System.out.println("Ciutat: " + ciutat);

        // Iterar l'array
        for (JsonNode t : root.withArray("temperatures")) {
            System.out.println("Temp: " + t.asInt());
        }
    }
}
```

> **Nota**: La crida a `root.withArray("temperatures")` √©s una forma de navegar l'arbre **JSON** utilitzant **Jackson**, i obtindre directament un array de nodes JSON.


---


# Anotacions en Jackson

*(Personalitzant el mapeig en JSON i XML)*

Quan treballem amb **Jackson**, per defecte el mapeig entre un objecte Java i un fitxer JSON o XML √©s autom√†tic:
cada atribut privat amb el seu *getter/setter* genera una clau JSON o un element XML amb el mateix nom.

Tanmateix, en projectes reals sovint necessitem **m√©s control**:

* Canviar noms de claus o elements.
* Ometre camps.
* Convertir un camp en **atribut XML**.
* Mostrar el contingut dins de **CDATA**.
* Donar **format a dates**.

Per aconseguir-ho, utilitzem **anotacions**.
Jackson t√© dos conjunts principals:

| Tipus d‚Äôanotaci√≥ | Paquet                                            | √Ämbit                                             |
| ---------------- | ------------------------------------------------- | ------------------------------------------------- |
| JSON             | `com.fasterxml.jackson.annotation`                | Serialitzaci√≥ i deserialitzaci√≥ de JSON           |
| XML              | `com.fasterxml.jackson.dataformat.xml.annotation` | Control d‚Äôetiquetes, atributs, wrappers, CDATA... |

---

## Anotacions JSON ‚Äì `com.fasterxml.jackson.annotation`

Este conjunt s‚Äôaplica quan treballem amb **ObjectMapper** i fitxers `.json`.

Permeten controlar com Jackson mapeja les propietats d‚Äôuna classe Java (POJO) cap a les claus d‚Äôun document JSON, i viceversa.

Les utilitzarem sobretot per:

- canviar noms de camps,
- ocultar informaci√≥ sensible,
- ometre valors nuls o per defecte,
- definir formats de data,
- o ignorar propietats desconegudes en la deserialitzaci√≥.
---

### `@JsonProperty("nom_json")`

Esta anotaci√≥ canvia el **nom de la clau** que apareix al **JSON** durant la serialitzaci√≥ o la deserialitzaci√≥. Es molt √∫til quan el nom del camp en Java no coincideix amb el nom desitjat en JSON.

**Exemple:**

```java
import com.fasterxml.jackson.annotation.JsonProperty;

public class Producte {
    @JsonProperty("nom_producte") // Clau personalitzada del JSON
    private String nom;

    private double preu;

    public Producte() {}
    public Producte(String nom, double preu) {
        this.nom = nom;
        this.preu = preu;
    }

    public String getNom() { return nom; }
    public double getPreu() { return preu; }
}
```

**Codi per a serialitzar:**

```java
ObjectMapper om = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
String json = om.writeValueAsString(new Producte("Ratol√≠", 19.95));
System.out.println(json);
```

**Eixida JSON:**

```json
{
  "nom_producte": "Ratol√≠",
  "preu": 19.95
}
```
>Jackson utilitzar√† nom_producte en lloc de nom.
>Aquesta anotaci√≥ tamb√© funciona a nivell de m√®todes **get** o **set**.

---

### `@JsonIgnore`

Evita que un camp aparega en el JSON, tant en la **serialitzaci√≥** (Java ‚Üí JSON) com en la **deserialitzaci√≥** (JSON ‚Üí Java).

S‚Äôutilitza, per exemple, per ocultar **dades sensibles** com contrasenyes o tokens.

**Exemple:**

```java
import com.fasterxml.jackson.annotation.JsonIgnore;

public class Usuari {
    private String nom;
    @JsonIgnore
    private String contrasenya;

    public Usuari() {}
    public Usuari(String nom, String contrasenya) {
        this.nom = nom;
        this.contrasenya = contrasenya;
    }
    // getters/setters
}
```

**Eixida JSON:**

```json
{
  "nom": "jaume"
}
```
> Esta anotaci√≥ tamb√© funciona a nivell de m√®todes **get** o **set**.

---

### `@JsonInclude(Include.NON_NULL)`

Omet camps que s√≥n `null`, buits o valors per defecte, esta etiqueta es √∫til per a reduir la mida del JSON i evitar informaci√≥ innecess√†ria, especialment en APIs i fitxers JSON grans.

**Exemple:**

```java
import com.fasterxml.jackson.annotation.JsonInclude;

@JsonInclude(JsonInclude.Include.NON_NULL)
public class Alumne {
    private String nom;
    private String email; // pot ser null

    public Alumne(String nom, String email) {
        this.nom = nom;
        this.email = email;
    }
}
```

**Serialitzar dos objectes:**

```java
ObjectMapper om = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
System.out.println(om.writeValueAsString(new Alumne("Maria", "maria@ies.com")));
System.out.println(om.writeValueAsString(new Alumne("Pere", null)));
```

**Eixida JSON:**

```json
{
  "nom": "Maria",
  "email": "maria@ies.com"
}
{
  "nom": "Pere"
}
```

> El segon objecte no mostra email perqu√® √©s null.

> Tamb√© es pot usar `Include.NON_EMPTY` (omiteix buits) o `Include.NON_DEFAULT` (omiteix valors per defecte) i `Include.ALWAYS` (sempre inclou).
---

### `@JsonFormat(pattern="dd-MM-yyyy")`

Controla el format de sortida i entrada de valors que representen dates, hores o n√∫meros.
Sense definir el patr√≥, Jackson mostra els objectes LocalDate o Date com a timestamps num√®rics.

**Exemple:**


```java
import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDate;

public class Event {
    private String nom;

    @JsonFormat(pattern = "dd-MM-yyyy")
    private LocalDate data;

    public Event(String nom, LocalDate data) {
        this.nom = nom;
        this.data = data;
    }
}
```

**Eixida JSON:**

```json
{
  "nom": "Concert",
  "data": "15-10-2025"
}
```

> Sense el patr√≥, la data apareixeria com a *timestamp num√®ric*.
> √âs recomanable registrar tamb√© el m√≤dul `JavaTimeModule`.

`@JsonFormat` t√© altres opcions √∫tils, com `shape` (per a definir si √©s string, n√∫mero, etc.) i `timezone` (per a zones hor√†ries).


```java
    @JsonFormat(
        pattern = "dd/MM/yyyy HH:mm",
        shape = JsonFormat.Shape.STRING,
        timezone = "Europe/Madrid"
    )
```

---

### `@JsonIgnoreProperties({"a","b"})`

Ignora diverses propietats alhora, √∫til quan llegim un document JSON amb m√©s camps dels que tenim a la nostra classe Java, i no volem que Jackson done error per camps desconeguts.

**Exemple:**

```java
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties({"id", "admin"})
public class Perfil {
    private String nom;
    private String rol;
    // getters/setters
}
```

**Si el JSON d‚Äôentrada √©s:**

```json
{
  "id": 1001,
  "nom": "Pau",
  "rol": "usuari",
  "admin": true
}
```

**Despr√©s de deserialitzar:**

```
nom = Pau
rol = usuari
```

> Els camps `id` i `admin` s‚Äôhan ignorat, encara que existien al JSON.


Si no sabem quins camps ignorar, podem usar `@JsonIgnoreProperties(ignoreUnknown = true)` per a ignorar tots els camps desconeguts.

```java
@JsonIgnoreProperties(ignoreUnknown = true)
public class Perfil {
    private String nom;
    private String rol;
}

```
Aix√≤ evita haver d‚Äôenumerar cada camp desconegut manualment i evita errors de deserialitzaci√≥.

---

### `@JsonGetter` i `@JsonSetter`

Permeten **personalitzar els noms** dels getters o setters sense canviar el nom real dels m√®todes o camps al codi Java.

**Exemple:**

```java
import com.fasterxml.jackson.annotation.JsonGetter;

public class Llibre {
    private String titol;

    @JsonGetter("nom_llibre")
    public String getTitol() {
        return titol;
    }

    public void setTitol(String titol) {
        this.titol = titol;
    }
}
```

**Eixida JSON:**

```json
{
  "nom_llibre": "1984"
}
```

> El nom del m√®tode continua sent **getTitol()**, per√≤ **Jackson** mostrar√† `nom_llibre` al JSON.

---
Aquest conjunt d‚Äôanotacions s‚Äôaplica quan fem servir **`XmlMapper`** per a llegir o escriure arxius `.xml`.
Permeten controlar **com es tradueixen les classes i camps Java a elements, atributs i estructures XML**.

Per utilitzar-les cal importar:

```java
import com.fasterxml.jackson.dataformat.xml.annotation.*;
```

Amb aquestes anotacions podem:

* Definir el **nom de l‚Äôelement arrel** (`@JacksonXmlRootElement`)
* Canviar el **nom d‚Äôun element** o fer que siga **atribut** (`@JacksonXmlProperty`)
* Agrupar **llistes** dins d‚Äôun contenidor (`@JacksonXmlElementWrapper`)
* Escriure **text intern o CDATA** (`@JacksonXmlText`, `@JacksonXmlCData`)

---

### `@JacksonXmlRootElement(localName="arrel")`

Defineix el **nom de l‚Äôelement arrel** del document XML.
Per defecte, Jackson utilitza el nom de la classe (`Persona`, `Producte`, etc.), per√≤ amb aquesta anotaci√≥ podem **personalitzar-lo**.

```java
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;

@JacksonXmlRootElement(localName = "persona")
public class Persona {
    private String nom;
    private int edat;

    public Persona() {}
    public Persona(String nom, int edat) {
        this.nom = nom;
        this.edat = edat;
    }

    public String getNom() { return nom; }
    public int getEdat() { return edat; }
}
```

**Eixida XML:**

```xml
<persona>
  <nom>Jaume</nom>
  <edat>30</edat>
</persona>
```

> Si no especifiquem `localName`, l‚Äôelement arrel s‚Äôanomenar√† igual que la classe (`<Persona>`).

**Arguments principals:**

* `localName`: nom de l‚Äôelement arrel del document.

---

### `@JacksonXmlProperty(localName="nom")` i `isAttribute=true`

Serveix per **canviar el nom d‚Äôun element** XML o indicar que ha de ser un **atribut** dins de l‚Äôetiqueta principal.

* Si **no** s‚Äôindica res, cada camp es converteix autom√†ticament en un **subelement**.
* Si s‚Äôindica `isAttribute = true`, apareixer√† com a **atribut XML** dins de la mateixa etiqueta.

**Exemple:**

```java
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;

public class Animal {
    // A l'XML vull l'atribut "tipus", per√≤ en Java el camp es diu "tipusAnimal"
    @JacksonXmlProperty(isAttribute = true, localName = "tipus")
    private String tipusAnimal;

    // A l'XML vull l'element <nom>, per√≤ en Java el camp es diu "nomComu"
    @JacksonXmlProperty(localName = "nom")
    private String nomComu;

    public Animal() {}

    public Animal(String tipusAnimal, String nomComu) {
        this.tipusAnimal = tipusAnimal;
        this.nomComu = nomComu;
    }

    public String getTipusAnimal() { return tipusAnimal; }
    public void setTipusAnimal(String tipusAnimal) { this.tipusAnimal = tipusAnimal; }

    public String getNomComu() { return nomComu; }
    public void setNomComu(String nomComu) { this.nomComu = nomComu; }
}

```

**Eixida XML:**

```xml
<Animal tipus="mam√≠fer">
  <nom>Lle√≥</nom>
</Animal>
```

> En aquest cas, `tipus` s‚Äôha convertit en **atribut** i `nom` en **subelement**.
> Si no pos√†rem `isAttribute = true`, el resultat seria `<tipus>mam√≠fer</tipus>`.

**Arguments principals:**

* `localName`: nom personalitzat per a l‚Äôelement o atribut.
* `isAttribute`: indica si el camp ha de ser un atribut (`true`) o un element (`false` per defecte).

---

### `@JacksonXmlElementWrapper` + `@JacksonXmlProperty`

S‚Äôutilitzen conjuntament per a **gestionar col¬∑leccions o llistes** (`List`, `Set`, etc.) dins d‚Äôun document XML.

* `@JacksonXmlElementWrapper` crea un **contenidor** per a tots els elements.
* `@JacksonXmlProperty` indica el **nom de cada element intern** dins de la llista.

**Exemple:**

```java
import com.fasterxml.jackson.dataformat.xml.annotation.*;
import java.util.List;

@JacksonXmlRootElement(localName = "zoologic")
public class Zoologic {
    @JacksonXmlElementWrapper(localName = "animals") // Contenidor de la llista
    @JacksonXmlProperty(localName = "animal")        // Nom de cada element dins
    private List<Animal> animals;

    public Zoologic() {}
    public Zoologic(List<Animal> animals) {
        this.animals = animals;
    }

    public List<Animal> getAnimals() { return animals; }
}
```

**Eixida XML:**

```xml
<zoologic>
  <animals>
    <animal><nom>Lle√≥</nom></animal>
    <animal><nom>Girafa</nom></animal>
  </animals>
</zoologic>
```

> Sense `@JacksonXmlElementWrapper`, els elements `<animal>` apareixerien directament un darrere d‚Äôun altre, **sense contenidor `<animals>`**.

**Arguments principals:**

* `localName`: nom del contenidor (per a `@JacksonXmlElementWrapper`) o del camp (per a `@JacksonXmlProperty`).
* `useWrapping`: `true` (per defecte) crea el contenidor; `false` el suprimeix.

---

### `@JacksonXmlCData`

Indica que el contingut del camp s‚Äôha d‚Äôenvoltar dins d‚Äôuna secci√≥ **CDATA**.
Aix√≤ evita que Jackson escape car√†cters especials (`<`, `>`, `&`), molt √∫til en textos llargs o fragments HTML.

**Exemple:**

```java
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlCData;

public class Noticia {
    private String titular;

    @JacksonXmlCData // Preserva el contingut sense escapament
    private String contingut;

    public Noticia() {}
    public Noticia(String titular, String contingut) {
        this.titular = titular;
        this.contingut = contingut;
    }

    public String getTitular() { return titular; }
    public String getContingut() { return contingut; }
}
```

**Eixida XML:**

```xml
<Noticia>
  <titular>√öltima hora</titular>
  <contingut><![CDATA[L'API ha fallat <500> errors m√∫ltiples]]></contingut>
</Noticia>
```

> Els car√†cters especials dins `<![CDATA[...]]>` no es processen com XML, es mantenen intactes.

**Arguments principals:**

* No t√© arguments. Aplica directament a un camp `String`.

---

### `@JacksonXmlText`

Assigna el valor directament com a **text intern de l‚Äôetiqueta**, en lloc de generar un subelement.
S‚Äôutilitza quan un element XML cont√© √∫nicament text i no m√©s etiquetes internes.

**Exemple:**

```java
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlText;

public class Valor {
    @JacksonXmlText // El text anir√† directament dins l‚Äôetiqueta
    private String contingut;

    public Valor() {}
    public Valor(String contingut) {
        this.contingut = contingut;
    }

    public String getContingut() { return contingut; }
}
```

**Eixida XML:**

```xml
<Valor>Text sense subetiquetes</Valor>
```

> Aquesta anotaci√≥ √©s molt pr√†ctica per a textos curts, valors num√®rics o missatges senzills.

---


### Resum anotacions

**JSON**

| **Anotaci√≥**                                 | **Funcionalitat / √ös principal**                                                                        | **Arguments m√©s habituals**                           |
| -------------------------------------------- | ------------------------------------------------------------------------------------------------------- | ----------------------------------------------------- |
| `@JsonProperty("nom_json")`                  | Canvia el nom de la clau al JSON. Permet usar noms diferents entre la classe Java i el document JSON.   | `value`: nou nom de la propietat.                     |
| `@JsonIgnore`                                | Exclou un camp de la serialitzaci√≥ i/o deserialitzaci√≥. Ideal per a dades sensibles (com contrasenyes). | ‚Äî                                                     |
| `@JsonInclude(JsonInclude.Include.NON_NULL)` | Omet camps nuls, buits o amb valor per defecte per reduir la mida del JSON.                             | `value`: `NON_NULL`, `NON_EMPTY`, `NON_DEFAULT`, etc. |
| `@JsonFormat(pattern="dd-MM-yyyy")`          | Defineix el format d‚Äôun valor, especialment dates (`LocalDate`, `Date`) o nombres.                      | `pattern`, `shape`, `timezone`                        |
| `@JsonIgnoreProperties({"a","b"})`           | Ignora diverses propietats alhora. Evita errors en deserialitzar JSONs amb camps desconeguts.           | `value`: camps a ignorar, `ignoreUnknown=true`        |
| `@JsonGetter("nom")`                         | Personalitza el nom que es mostrar√† al JSON per un getter.                                              | `value`: nom de la clau al JSON.                      |
| `@JsonSetter("nom")`                         | Personalitza el nom esperat al llegir un JSON (deserialitzaci√≥).                                        | `value`: nom de la clau al JSON.                      |
| `@JsonAnySetter` / `@JsonAnyGetter`          | Assigna o recupera propietats desconegudes a un `Map`. √ötil per JSONs flexibles.                        | ‚Äî                                                     |
| `@JsonAutoDetect`                            | Controla quins camps o m√®todes s√≥n visibles per a Jackson (encara que no tinguen getters/setters).      | `fieldVisibility`, `getterVisibility`, etc.           |
| `@JsonSerialize` / `@JsonDeserialize`        | Permet definir una classe pr√≤pia per a (de)serialitzar camps amb l√≤gica personalitzada.                 | `using`: classe del (de)serialitzador personalitzat.  |


---

**XML**

| **Anotaci√≥**                                             | **Funcionalitat / √ös principal**                                                                             | **Arguments m√©s habituals**                                                     |
| -------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------- |
| `@JacksonXmlRootElement(localName="arrel")`              | Defineix el **nom de l‚Äôelement arrel** del document XML (equivalent al nom de la classe).                    | `localName`: nom de l‚Äôarrel.                                                    |
| `@JacksonXmlProperty(localName="nom", isAttribute=true)` | Canvia el **nom** d‚Äôun element o el converteix en **atribut** XML.                                           | `localName`: nom nou. `isAttribute`: `true` si √©s atribut.                      |
| `@JacksonXmlElementWrapper(localName="contenidor")`      | Agrupa una llista o col¬∑lecci√≥ dins d‚Äôun contenidor. Evita que apareguen elements sense agrupaci√≥.           | `localName`: nom del contenidor. `useWrapping`: activa o desactiva l‚Äôembolcall. |
| `@JacksonXmlCData`                                       | Indica que el contingut s‚Äôha d‚Äôenvoltar amb **CDATA**, preservant car√†cters especials (`<`, `>`, `&`, etc.). | ‚Äî                                                                               |
| `@JacksonXmlText`                                        | Escriu el valor del camp com a **text intern** de l‚Äôetiqueta, no com a subelement.                           | ‚Äî                                                                               |

> üí° **Recorda:**
> En XML, les anotacions serveixen per **controlar la jerarquia i aparen√ßa exacta** del document:
>
> * `@JacksonXmlRootElement` ‚Üí controla el nom de l‚Äôarrel.
> * `@JacksonXmlProperty` ‚Üí controla subelements o atributs.
> * `@JacksonXmlElementWrapper` ‚Üí controla agrupacions (`<llista> ... </llista>`).
> * `@JacksonXmlCData` i `@JacksonXmlText` ‚Üí controlen el contingut intern.

---

> Les anotacions de **Jackson per a JSON** controlen sobretot **noms, visibilitat i formats**,
> mentre que les d‚Äô**XML** controlen **estructura, jerarquia i atributs**.
> Les dos comparteixen la mateixa filosofia: **mapejar classes Java a dades estructurades d‚Äôuna manera precisa i llegible**.




---

## Bones pr√†ctiques i errors t√≠pics 

* **Constructor buit** als POJOs: sense ell, Jackson no pot crear l‚Äôobjecte.
* **Getters/Setters** coherents (especialment booleans amb `isXxx`).
* **Rutes de fitxer**: usa `src/main/resources` per a dades; en proves, comprova `exists()`.
* **Dates**: `JavaTimeModule` + `WRITE_DATES_AS_TIMESTAMPS` **desactivat**.
* **Col¬∑leccions**: per a XML, quasi sempre necessitar√†s `@JacksonXmlElementWrapper` + `@JacksonXmlProperty`.
* **Estructures desconegudes**: si no tens POJOs, `JsonNode` √©s el teu amic.
* **Pretty-print**: `INDENT_OUTPUT` o `writerWithDefaultPrettyPrinter()` per a llegibilitat.

---

# 8) Serialitzaci√≥ i deserialitzaci√≥ guiat (exemple ‚ÄúPersona/Adre√ßa‚Äù complet)

## 8.1. XML 

**XML d‚Äôentrada:**

```xml
<persona>
    <nom>Jaume Arag√≥</nom>
    <edat>68</edat>
    <adreces>
        <adreca tipus="casa">
            <carrer>Avinguda Datileres</carrer>
            <ciutat>Benizahat</ciutat>
        </adreca>
        <adreca tipus="oficina">
            <carrer>Canto del Bobet</carrer>
            <ciutat>Benigaslo</ciutat>
        </adreca>
    </adreces>
    <notes><![CDATA[Esta √©s una persona molt important.]]></notes>
</persona>
```

**POJOs + Anotacions XML (per a mapejar exactament):**

```java
// Persona.java
import com.fasterxml.jackson.dataformat.xml.annotation.*;
import java.util.List;

@JacksonXmlRootElement(localName = "persona")
public class Persona {
    @JacksonXmlProperty(localName = "nom")
    private String nom;

    @JacksonXmlProperty(localName = "edat")
    private int edat;

    @JacksonXmlElementWrapper(localName = "adreces") // <adreces> ... </adreces>
    @JacksonXmlProperty(localName = "adreca")        // elements fills <adreca>
    private List<Adreca> adreces;

    @JacksonXmlCData // Volem que vaja dins CDATA
    private String notes;

    public Persona() {}
    // getters/setters...
}

// Adreca.java
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;

public class Adreca {
    @JacksonXmlProperty(isAttribute = true, localName = "tipus") // atribut <adreca tipus="...">
    private String tipus;

    @JacksonXmlProperty(localName = "carrer")
    private String carrer;

    @JacksonXmlProperty(localName = "ciutat")
    private String ciutat;

    public Adreca() {}
    // getters/setters...
}
```

**Deserialitzar l‚ÄôXML i mostrar-ho**:

```java
// LligXML.java
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import java.io.File;

public class LligXML {
    public static void main(String[] args) throws Exception {
        XmlMapper xml = new XmlMapper();

        // 1) Des de String (√∫til per a proves o exemples curts)
        String xmlContent = """
            <persona>
              <nom>Jaume Arag√≥</nom>
              <edat>68</edat>
              <adreces>
                <adreca tipus="casa">
                  <carrer>Avinguda Datileres</carrer>
                  <ciutat>Benizahat</ciutat>
                </adreca>
                <adreca tipus="oficina">
                  <carrer>Canto del Bobet</carrer>
                  <ciutat>Benigaslo</ciutat>
                </adreca>
              </adreces>
              <notes><![CDATA[Esta √©s una persona molt important.]]></notes>
            </persona>
        """;
        Persona p = xml.readValue(xmlContent, Persona.class);
        System.out.println("Nom: " + p.getNom() + " | Edat: " + p.getEdat());
        for (Adreca a : p.getAdreces()) {
            System.out.println(" - " + a.getTipus() + " ‚Üí " + a.getCarrer() + " (" + a.getCiutat() + ")");
        }
        System.out.println("Notes: " + p.getNotes());

        // 2) Des de fitxer
        File f = new File("src/main/resources/persona.xml");
        if (f.exists()) {
            Persona p2 = xml.readValue(f, Persona.class);
            System.out.println("Fitxer OK ‚Üí " + p2.getNom());
        }
    }
}
```

**Serialitzar a XML amb cap√ßalera i indentaci√≥:**

```java
// EscriuXML.java
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.io.File;
import java.util.List;

public class EscriuXML {
    public static void main(String[] args) throws Exception {
        Persona p = new Persona();
        p.setNom("Jaume Arag√≥");
        p.setEdat(68);
        p.setAdreces(List.of(
            crea("casa", "Avinguda Datileres", "Benizahat"),
            crea("oficina", "Canto del Bobet", "Benigaslo")
        ));
        p.setNotes("Aquesta √©s una persona molt important.");

        XmlMapper xml = new XmlMapper();
        xml.configure(ToXmlGenerator.Feature.WRITE_XML_DECLARATION, true); // <?xml ...?>
        xml.enable(SerializationFeature.INDENT_OUTPUT);

        String out = xml.writeValueAsString(p);
        System.out.println(out);

        xml.writeValue(new File("src/main/resources/persona_out.xml"), p);
    }

    private static Adreca crea(String tipus, String carrer, String ciutat) {
        Adreca a = new Adreca();
        a.setTipus(tipus);
        a.setCarrer(carrer);
        a.setCiutat(ciutat);
        return a;
    }
}
```

## 8.2. JSON 

**POJOs sense anotacions** (nom per defecte = nom del camp):

```java
// Empresa.java
import java.util.List;

public class Empresa {
    private String nom;
    private List<Empleat> empleats;

    public Empresa() {}
    public Empresa(String nom, List<Empleat> empleats) {
        this.nom = nom;
        this.empleats = empleats;
    }
    public String getNom() { return nom; }
    public void setNom(String nom) { this.nom = nom; }
    public List<Empleat> getEmpleats() { return empleats; }
    public void setEmpleats(List<Empleat> empleats) { this.empleats = empleats; }
}

public class Empleat {
    private String nom;
    private int edat;

    public Empleat() {}
    public Empleat(String nom, int edat) { this.nom = nom; this.edat = edat; }
    public String getNom() { return nom; }
    public void setNom(String nom) { this.nom = nom; }
    public int getEdat() { return edat; }
    public void setEdat(int edat) { this.edat = edat; }
}
```

**Serialitzar a JSON amb indentaci√≥:**

```java
// EscriuJSON.java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.io.File;
import java.util.List;

public class EscriuJSON {
    public static void main(String[] args) throws Exception {
        Empresa empresa = new Empresa(
            "La mazmorra del Androide",
            List.of(new Empleat("Jaume", 30), new Empleat("Bel", 28))
        );

        ObjectMapper om = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);

        System.out.println(om.writeValueAsString(empresa)); // a consola
        om.writeValue(new File("src/main/resources/empresa.json"), empresa); // a fitxer
    }
}
```

**Deserialitzar JSON des de fitxer:**

```java
// LligJSON.java
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.File;

public class LligJSON {
    public static void main(String[] args) throws Exception {
        File f = new File("src/main/resources/empresa.json");
        if (!f.exists()) {
            System.err.println("No trobe empresa.json. Executa abans EscriuJSON.");
            return;
        }
        ObjectMapper om = new ObjectMapper();
        Empresa emp = om.readValue(f, Empresa.class);

        System.out.println("Empresa: " + emp.getNom());
        for (Empleat e : emp.getEmpleats()) {
            System.out.println(" - " + e.getNom() + " (" + e.getEdat() + ")");
        }
    }
}
```

---

# 9) Annex r√†pid: recordatori de m√®todes clau (JSON i XML)

* **Serialitzar (objecte ‚Üí text)**

  * `writeValueAsString(obj)` ‚Üí `String` (JSON o XML segons Mapper)
  * `writeValue(File, obj)` ‚Üí escriu a fitxer
  * `writerWithDefaultPrettyPrinter().writeValueAsString(obj)` ‚Üí ‚Äúbonic‚Äù

* **Deserialitzar (text ‚Üí objecte)**

  * `readValue(String/File, Classe.class)`
  * `readTree(...)` ‚Üí arbre (`JsonNode`) quan no tens POJO

* **Configuraci√≥ habitual**

  * `enable(SerializationFeature.INDENT_OUTPUT)`
  * `registerModule(new JavaTimeModule())`
  * `disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)`
  * **XML**: `configure(ToXmlGenerator.Feature.WRITE_XML_DECLARATION, true)`

---
