---
title: 2.4.- Jackson. Serialitzant - Deserialitzat.
parent: 2.- Gestió del Contingut
grand_parent: Persistència de Fitxers
has_children: true
layout: default
nav_order: 40
---




# Mapejant amb Jackson 

(Serialització i Deserialització JSON i XML)


Recorda que:

| Procés              | Descripció                            | Exemple                                |
| ------------------- | ------------------------------------- | -------------------------------------- |
| **Serialització**   | Convertir un objecte Java en JSON/XML | `mapper.writeValueAsString(obj)`       |
| **Deserialització** | Convertir JSON/XML en un objecte Java | `mapper.readValue(json, Classe.class)` |


Per a **mapejar** dades estructurades (JSON o XML) a **classes Java (POJOs/DTOs)**. Jackson ens ofereix un **nucli comú** d’anotacions i configuració que serveix tant per a JSON com per a XML, i un **conjunt reduït d’anotacions específiques d’XML** per a casos concrets (atributs, wrapper de llistes, etc.)

Per tant, es poden **reutilitzar les mateixes classes** per als dos formats i només afegir ajustos d’XML quan calga.

---


##  Serialització (Java → JSON/XML) amb Jackson

L’objectiu és convertir **objectes Java** (POJOs/DTOs) a **text**: JSON o XML.
La peça clau és:

* **JSON** → `ObjectMapper` (mòdul jackson-databind)
* **XML** → `XmlMapper` (mòdul jackson-dataformat-xml)

### Mètodes essencials (i què retornen)

> No memoritzem, **entenguem**: “write” escriu (serialitza), “read” llig (deserialitza). Les versions “AsString” retornen una **String**; les que no, escriuen a **fitxer** o **flux**.

### Per a JSON (`ObjectMapper`)

| Retorn         | Mètode                                       | Què fa                                                                                                                |
| -------------- | -------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| `String`       | `writeValueAsString(Object value)`           | Converteix l’objecte a **JSON** en una `String`.                                                                      |
| `void`         | `writeValue(File file, Object value)`        | Escriu l’objecte com a **JSON** dins d’un fitxer.                                                                     |
| `void`         | `writeValue(OutputStream out, Object value)` | Escriu el **JSON** cap a un **Stream** (ex: `FileOutputStream`).                                                      |
| `ObjectWriter` | `writerWithDefaultPrettyPrinter()`           | Prepara un **escriptor** que indenta/formateta l’eixida. (S’usa amb `.writeValueAsString(...)` o `.writeValue(...)`.) |

### Per a XML (`XmlMapper`)

És el mateix patró, però amb XML:

| Retorn   | Mètode                                       | Què fa                                           |
| -------- | -------------------------------------------- | ------------------------------------------------ |
| `String` | `writeValueAsString(Object value)`           | Converteix l’objecte a **XML** en una `String`.  |
| `void`   | `writeValue(File file, Object value)`        | Escriu l’objecte com a **XML** dins d’un fitxer. |
| `void`   | `writeValue(OutputStream out, Object value)` | Escriu l’**XML** cap a un **Stream**.            |

> **Truc didàctic:** per a **JSON**, sempre `new ObjectMapper()`. Per a **XML**, sempre `new XmlMapper()`.

### Configuració bàsica (dates, pretty-print, etc.)

* **Indentació**: `mapper.enable(SerializationFeature.INDENT_OUTPUT)` **o** `mapper.writerWithDefaultPrettyPrinter()...`
* **Dates modernes (Java Time API)**: registra `JavaTimeModule` i desactiva timestamps.

```java
// JSON
ObjectMapper json = new ObjectMapper()
        .registerModule(new JavaTimeModule()) // LocalDate, LocalDateTime, ...
        .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS) // 2025-10-13 en lloc de número
        .enable(SerializationFeature.INDENT_OUTPUT); // format identat

// XML
XmlMapper xml = (XmlMapper) new XmlMapper()
        .registerModule(new JavaTimeModule())
        .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
        .enable(SerializationFeature.INDENT_OUTPUT);
```

> **Per què?** Sense `JavaTimeModule`, `LocalDate` dona problemes o ix com a timestamp.
> Amb `INDENT_OUTPUT`, l’eixida és llegible per a classe i exàmens.

## Exemple complet JSON i XML

Partim de la classe java senzilla (o POJO):



```java
// Producte.java
// POJO sense anotacions. Constructors buits i getters/setters perquè Jackson puga accedir.
public class Producte {
    private String nom;
    private double preu;
    private boolean actiu;

    public Producte() {} // Obligatori per a Jackson (constructor per defecte)

    public Producte(String nom, double preu, boolean actiu) {
        this.nom = nom;
        this.preu = preu;
        this.actiu = actiu;
    }

    public String getNom() { return nom; }
    public void setNom(String nom) { this.nom = nom; }

    public double getPreu() { return preu; }
    public void setPreu(double preu) { this.preu = preu; }

    public boolean isActiu() { return actiu; } // per a booleans, isXxx és OK
    public void setActiu(boolean actiu) { this.actiu = actiu; }
}
```

### Serialitzar a **JSON** (String i Fitxer)

En aquest exemple, serialitzem un objecte `Producte` a JSON, primer com a `String` i després a un fitxer.

```java
// SerialitzaJSON.java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import java.io.File;

public class SerialitzaJSON {
    public static void main(String[] args) throws Exception {
        // 1) Creem dades Java
        Producte p = new Producte("Ratolí Gamer", 24.99, true);

        // 2) Configurem l'ObjectMapper
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        mapper.enable(SerializationFeature.INDENT_OUTPUT);

        // 3) Obtenir JSON com a String (per a mostrar per consola/log)
        String json = mapper.writeValueAsString(p); // <-- No toca disc, només genera una String
        System.out.println("JSON en String:");
        System.out.println(json);

        // 4) Escriure JSON a fitxer (src/main/resources és bona ubicació per a dades)
        File out = new File("src/main/resources/producte.json");
        mapper.writeValue(out, p); // <-- Ara sí, a disc
        System.out.println("S'ha guardat a: " + out.getAbsolutePath());
    }
}
```
L'eixida per consola serà:

```json
{
  "nom" : "Ratolí Gamer",
  "preu" : 24.99,
  "actiu" : true
}
```


### Serialitzar a **XML** (String i Fitxer)

```java
// SerialitzaXML.java
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;
import java.io.File;

public class SerialitzaXML {
    public static void main(String[] args) throws Exception {
        Producte p = new Producte("Ratolí Gamer", 24.99, true);

        XmlMapper xml = new XmlMapper();
        xml.registerModule(new JavaTimeModule());
        xml.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        xml.enable(SerializationFeature.INDENT_OUTPUT);
        // Opcional: afegir la capçalera XML <?xml ...?>
        xml.configure(ToXmlGenerator.Feature.WRITE_XML_DECLARATION, true);

        String xmlString = xml.writeValueAsString(p);
        System.out.println("XML en String:");
        System.out.println(xmlString);

        File out = new File("src/main/resources/producte.xml");
        xml.writeValue(out, p);
        System.out.println("S'ha guardat a: " + out.getAbsolutePath());
    }
}
```

L'eixida per consola serà:

```xml
<?xml version='1.0' encoding='UTF-8'?>
<Producte>
  <nom>Ratolí Gamer</nom>
  <preu>24.99</preu>
  <actiu>true</actiu>
</Producte>
```


> **Nota XML**: Com que no hem posat anotacions d’XML, Jackson deriva noms d’etiqueta dels **noms de camp**.
> Si després vols `<nom_producte>` en lloc de `<nom>`, tindrem que posar **anotacions XML**.

## Serialitzar llistes i objectes anidats

```java
// Cataleg.java
import java.util.List;

public class Cataleg {
    private String nom;
    private List<Producte> productes;

    public Cataleg() {}
    public Cataleg(String nom, List<Producte> productes) {
        this.nom = nom;
        this.productes = productes;
    }
    public String getNom() { return nom; }
    public void setNom(String nom) { this.nom = nom; }
    public List<Producte> getProductes() { return productes; }
    public void setProductes(List<Producte> productes) { this.productes = productes; }
}
```

```java
// SerialitzaColleccions.java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.util.List;
import java.io.File;

public class SerialitzaColleccions {
    public static void main(String[] args) throws Exception {
        Cataleg cat = new Cataleg(
            "Perifèrics",
            List.of(
                new Producte("Ratolí Gamer", 24.99, true),
                new Producte("Teclat Mecànic", 59.90, true)
            )
        );

        ObjectMapper om = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
        // A String
        System.out.println(om.writeValueAsString(cat));
        // A fitxer
        om.writeValue(new File("src/main/resources/cataleg.json"), cat);
    }
}
```

El resultat JSON serà:

```json
{
  "nom" : "Perifèrics",
  "productes" : [ {
    "nom" : "Ratolí Gamer",
    "preu" : 24.99,
    "actiu" : true
  }, {
    "nom" : "Teclat Mecànic",
    "preu" : 59.9,
    "actiu" : true
  } ]
}
```


La versió amb `XmlMapper` és idèntica, només canviant la classe i el nom del fitxer.

* **Es a dir, canviem `ObjectMapper` per `XmlMapper` i `cataleg.json` per `cataleg.xml`.**

i l'eixida serà:

```xml
<?xml version='1.0' encoding='UTF-8'?>
<Cataleg>
  <nom>Perifèrics</nom>
  <productes>
    <productes>
      <nom>Ratolí Gamer</nom>
      <preu>24.99</preu>
      <actiu>true</actiu>
    </productes>
    <productes>
      <nom>Teclat Mecànic</nom>
      <preu>59.9</preu>
      <actiu>true</actiu>
    </productes>
  </productes>
</Cataleg>
```


---

##  Deserialització (JSON/XML → Java)

Ara fem el camí contrari: **a partir d’un text** (JSON o XML) o un **fitxer**, Jackson crea **objectes Java**.

### Mètodes de lectura

* **JSON (`ObjectMapper`)**

| Retorn     | Mètode                                          | Què fa                                                                |
| ---------- | ----------------------------------------------- | --------------------------------------------------------------------- |
| `<T>`      | `readValue(String content, Class<T> valueType)` | Converteix una **String JSON** a un objecte Java.                     |
| `<T>`      | `readValue(File src, Class<T> valueType)`       | Converteix un **fitxer JSON** a un objecte Java.                      |
| `JsonNode` | `readTree(String/Reader/File/InputStream)`      | Llig el JSON com a **arbre** (quan no tens POJO o vols inspeccionar). |

* **XML (`XmlMapper`)**

Exactament igual, però amb `XmlMapper`.

### Deserialitzar JSON (String i Fitxer)

En este exemple partime del string JSON i d’un fitxer `producte.json`:

``` java 
String json = """ 
{ "nom": "Raton Gamer", "preu": 24.99, "actiu": true } 
""";

El fitxer `producte.json` hauria de tenir el format:

```json
{
  "nom": "Raton Gamer",
  "preu": 24.99,
  "actiu": true
}
```

```java
// DeserialitzaJSON.java
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.File;

public class DeserialitzaJSON {
    public static void main(String[] args) throws Exception {
        ObjectMapper om = new ObjectMapper();

        // 1) Des de String
        String json = """
          { "nom": "Raton Gamer", "preu": 24.99, "actiu": true }
        """;
        Producte p = om.readValue(json, Producte.class);
        System.out.println("Nom: " + p.getNom() + ", preu: " + p.getPreu());

        // 2) Des de Fitxer
        File f = new File("src/main/resources/producte.json");
        if (f.exists()) {
            Producte p2 = om.readValue(f, Producte.class);
            System.out.println("Des de fitxer → " + p2.getNom());
        } else {
            System.err.println("No trobe el fitxer producte.json");
        }
    }
}
```

 

### Deserialitzar XML (String i Fitxer)

```java
// DeserialitzaXML.java
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import java.io.File;

public class DeserialitzaXML {
    public static void main(String[] args) throws Exception {
        XmlMapper xml = new XmlMapper();

        String xmlString = """
          <Producte>
            <nom>Raton Gamer</nom>
            <preu>24.99</preu>
            <actiu>true</actiu>
          </Producte>
        """;

        Producte p = xml.readValue(xmlString, Producte.class);
        System.out.println("Nom: " + p.getNom() + ", actiu: " + p.isActiu());

        File f = new File("src/main/resources/producte.xml");
        if (f.exists()) {
            Producte p2 = xml.readValue(f, Producte.class);
            System.out.println("Des de fitxer → " + p2.getNom());
        }
    }
}
```

El fitxer `producte.xml` hauria de tenir el format:

```xml
<Producte>
  <nom>Raton Gamer</nom>
  <preu>24.99</preu>
  <actiu>true</actiu>
</Producte>
``` 


### Quan **no tens POJOs** o el JSON és “lliure”: `JsonNode`

```java
// Llegir sense classe, recorrent l'arbre
import com.fasterxml.jackson.databind.*;

public class LlegirComArbre {
    public static void main(String[] args) throws Exception {
        String json = """
          { "ciutat":"Madrid", "temperatures":[19,21,18,23,20] }
        """;
        ObjectMapper om = new ObjectMapper();
        JsonNode root = om.readTree(json); // Arrel de l’arbre

        String ciutat = root.get("ciutat").asText();
        System.out.println("Ciutat: " + ciutat);

        // Iterar l'array
        for (JsonNode t : root.withArray("temperatures")) {
            System.out.println("Temp: " + t.asInt());
        }
    }
}
```

---



# Anotacions en Jackson

*(Personalitzant el mapeig en JSON i XML)*

Quan treballem amb **Jackson**, per defecte el mapeig entre un objecte Java i un fitxer JSON o XML és automàtic:
cada atribut privat amb el seu *getter/setter* genera una clau JSON o un element XML amb el mateix nom.

Tanmateix, en projectes reals sovint necessitem **més control**:

* Canviar noms de claus o elements.
* Ometre camps.
* Convertir un camp en **atribut XML**.
* Mostrar el contingut dins de **CDATA**.
* Donar **format a dates**.

Per aconseguir-ho, utilitzem **anotacions**.
Jackson té dos conjunts principals:

| Tipus d’anotació | Paquet                                            | Àmbit                                             |
| ---------------- | ------------------------------------------------- | ------------------------------------------------- |
| JSON             | `com.fasterxml.jackson.annotation`                | Serialització i deserialització de JSON           |
| XML              | `com.fasterxml.jackson.dataformat.xml.annotation` | Control d’etiquetes, atributs, wrappers, CDATA... |

---

## Anotacions JSON – `com.fasterxml.jackson.annotation`

Este conjunt s’aplica quan treballem amb **ObjectMapper** i fitxers `.json`.

---

### `@JsonProperty("nom_json")`

Canvia el **nom de la clau** al JSON.

**Exemple:**

```java
import com.fasterxml.jackson.annotation.JsonProperty;

public class Producte {
    @JsonProperty("nom_producte") // Clau personalitzada
    private String nom;

    private double preu;

    public Producte() {}
    public Producte(String nom, double preu) {
        this.nom = nom;
        this.preu = preu;
    }

    public String getNom() { return nom; }
    public double getPreu() { return preu; }
}
```

**Codi per a serialitzar:**

```java
ObjectMapper om = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
String json = om.writeValueAsString(new Producte("Ratolí", 19.95));
System.out.println(json);
```

**Eixida JSON:**

```json
{
  "nom_producte": "Ratolí",
  "preu": 19.95
}
```



---

### `@JsonIgnore`

Evita que un camp aparega en la serialització i/o deserialització, esta anotació és útil per ocultar dades sensibles.

**Exemple:**

```java
import com.fasterxml.jackson.annotation.JsonIgnore;

public class Usuari {
    private String nom;
    @JsonIgnore
    private String contrasenya;

    public Usuari() {}
    public Usuari(String nom, String contrasenya) {
        this.nom = nom;
        this.contrasenya = contrasenya;
    }
    // getters/setters
}
```

**Eixida JSON:**

```json
{
  "nom": "jaume"
}
```


---

### `@JsonInclude(Include.NON_NULL)`

Omet camps que són `null`, buits o valors per defecte, esta etiqueta es útil per a reduir la mida del JSON i evitar informació innecessària, especialment en APIs i fitxers JSON grans.

**Exemple:**

```java
import com.fasterxml.jackson.annotation.JsonInclude;

@JsonInclude(JsonInclude.Include.NON_NULL)
public class Alumne {
    private String nom;
    private String email; // pot ser null

    public Alumne(String nom, String email) {
        this.nom = nom;
        this.email = email;
    }
}
```

**Serialitzar dos objectes:**

```java
ObjectMapper om = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
System.out.println(om.writeValueAsString(new Alumne("Maria", "maria@ies.com")));
System.out.println(om.writeValueAsString(new Alumne("Pere", null)));
```

**Eixida JSON:**

```json
{
  "nom": "Maria",
  "email": "maria@ies.com"
}
{
  "nom": "Pere"
}
```

---

### `@JsonFormat(pattern="dd-MM-yyyy")`

Controla el **format de dates**.

**Exemple:**

```java
import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDate;

public class Event {
    private String nom;

    @JsonFormat(pattern = "dd-MM-yyyy")
    private LocalDate data;

    public Event(String nom, LocalDate data) {
        this.nom = nom;
        this.data = data;
    }
}
```

**Eixida JSON:**

```json
{
  "nom": "Concert",
  "data": "15-10-2025"
}
```

> Sense el patró, la data apareixeria com a *timestamp numèric*.
> És recomanable registrar també el mòdul `JavaTimeModule`.

---

### `@JsonIgnoreProperties({"a","b"})`

Ignora diverses propietats alhora, útil quan llegim un document JSON amb més camps dels que tenim a la nostra classe Java, i no volem que Jackson done error per camps desconeguts.

**Exemple:**

```java
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties({"id", "admin"})
public class Perfil {
    private String nom;
    private String rol;
    // getters/setters
}
```

**Si el JSON d’entrada és:**

```json
{
  "id": 1001,
  "nom": "Pau",
  "rol": "usuari",
  "admin": true
}
```

**Després de deserialitzar:**

```
nom = Pau
rol = usuari
```

Si no sabem quins camps ignorar, podem usar `@JsonIgnoreProperties(ignoreUnknown = true)` per a ignorar tots els camps desconeguts.

```java
@JsonIgnoreProperties(ignoreUnknown = true)
public class Perfil {
    private String nom;
    private String rol;
}

```
Així evitarem denumerar els camps un per un.

---

### `@JsonGetter` i `@JsonSetter`

Permeten personalitzar els noms dels getters o setters sense canviar el nom real del mètode.

**Exemple:**

```java
import com.fasterxml.jackson.annotation.JsonGetter;

public class Llibre {
    private String titol;

    @JsonGetter("nom_llibre")
    public String getTitol() {
        return titol;
    }

    public void setTitol(String titol) {
        this.titol = titol;
    }
}
```

**Eixida JSON:**

```json
{
  "nom_llibre": "1984"
}
```



---

## Anotacions XML 

Aquestes s’apliquen quan fem servir **XmlMapper** i volem controlar el format exacte dels elements i atributs XML.

Cal importar `com.fasterxml.jackson.dataformat.xml.annotation.*`.

---

### `@JacksonXmlRootElement(localName="arrel")`

Defineix el **nom de l’element arrel**.

```java
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;

@JacksonXmlRootElement(localName = "persona")
public class Persona {
    private String nom;
    private int edat;
}
```

**Eixida XML:**

```xml
<persona>
  <nom>Jaume</nom>
  <edat>30</edat>
</persona>
```

---

### `@JacksonXmlProperty(localName="nom")` i `isAttribute=true`

Canvia el nom de l’element o el converteix en atribut XML.

```java
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;

public class Animal {
    @JacksonXmlProperty(isAttribute = true, localName = "tipus")
    private String tipus;

    @JacksonXmlProperty(localName = "nom")
    private String nom;
}
```

**Eixida XML:**

```xml
<Animal tipus="mamífer">
  <nom>Lleó</nom>
</Animal>
```


---

### `@JacksonXmlElementWrapper` + `@JacksonXmlProperty`

Agrupa una llista dins d’un contenidor.

```java
import com.fasterxml.jackson.dataformat.xml.annotation.*;
import java.util.List;

@JacksonXmlRootElement(localName = "zoologic")
public class Zoologic {
    @JacksonXmlElementWrapper(localName = "animals")
    @JacksonXmlProperty(localName = "animal")
    private List<Animal> animals;
}
```

**Eixida XML:**

```xml
<zoologic>
  <animals>
    <animal><nom>Lleó</nom></animal>
    <animal><nom>Girafa</nom></animal>
  </animals>
</zoologic>
```



> Sense `@JacksonXmlElementWrapper`, els elements `<animal>` apareixerien sense contenidor `<animals>`.

---

### `@JacksonXmlCData`

Indica que el text s’ha d’envoltar amb **CDATA** per preservar caràcters especials.

```java
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlCData;

public class Noticia {
    private String titular;
    @JacksonXmlCData
    private String contingut;
}
```

**Eixida XML:**

```xml
<Noticia>
  <titular>Última hora</titular>
  <contingut><![CDATA[L'API ha fallat <500> errors múltiples]]></contingut>
</Noticia>
```



---

### `@JacksonXmlText`

Assigna el valor directament com a text intern, no com a subelement.

```java
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlText;

public class Valor {
    @JacksonXmlText
    private String contingut;
}
```

**Eixida XML:**

```xml
<Valor>Text sense subetiquetes</Valor>
```


---

## Combinació d’anotacions JSON i XML

Podem usar **les dues famílies d’anotacions alhora** per a obtenir un resultat coherent en ambdós formats.

**Exemple complet:**

```java
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.dataformat.xml.annotation.*;

@JacksonXmlRootElement(localName="planeta")
public class Planeta {
    @JsonProperty("nom_planeta")
    @JacksonXmlProperty(localName="nom_planeta")
    private String nom;

    @JacksonXmlProperty(isAttribute=true)
    private boolean teAnells;

    @JacksonXmlCData
    private String descripcio;
}
```

**Eixida JSON:**

```json
{
  "nom_planeta": "Saturn",
  "teAnells": true,
  "descripcio": "Planeta gasós amb anells visibles"
}
```

**Eixida XML:**

```xml
<planeta teAnells="true">
  <nom_planeta>Saturn</nom_planeta>
  <descripcio><![CDATA[Planeta gasós amb anells visibles]]></descripcio>
</planeta>
```

> Els noms són consistents en JSON i XML gràcies a `@JsonProperty` + `@JacksonXmlProperty`.
> L’atribut `teAnells` és un **atribut XML** però continua sent una **clau normal en JSON**.

---



### Resum anotacions

| Àmbit | Anotació                    | Efecte principal              |
| ----- | --------------------------- | ----------------------------- |
| JSON  | `@JsonProperty("nom")`      | Nom personalitzat de clau     |
| JSON  | `@JsonIgnore`               | Omet el camp                  |
| JSON  | `@JsonInclude`              | Exclou valors nuls/buits      |
| JSON  | `@JsonFormat`               | Format de dates/nombres       |
| JSON  | `@JsonIgnoreProperties`     | Ignora múltiples propietats   |
| XML   | `@JacksonXmlRootElement`    | Nom de l’arrel XML            |
| XML   | `@JacksonXmlProperty`       | Nom de subelement o atribut   |
| XML   | `@JacksonXmlElementWrapper` | Contenidor per a col·leccions |
| XML   | `@JacksonXmlCData`          | Escriu CDATA                  |
| XML   | `@JacksonXmlText`           | Text intern                   |




---

# 7) Bones pràctiques i errors típics (que veurem a classe)

* **Constructor buit** als POJOs: sense ell, Jackson no pot crear l’objecte.
* **Getters/Setters** coherents (especialment booleans amb `isXxx`).
* **Rutes de fitxer**: usa `src/main/resources` per a dades; en proves, comprova `exists()`.
* **Dates**: `JavaTimeModule` + `WRITE_DATES_AS_TIMESTAMPS` **desactivat**.
* **Col·leccions**: per a XML, quasi sempre necessitaràs `@JacksonXmlElementWrapper` + `@JacksonXmlProperty`.
* **Estructures desconegudes**: si no tens POJOs, `JsonNode` és el teu amic.
* **Pretty-print**: `INDENT_OUTPUT` o `writerWithDefaultPrettyPrinter()` per a llegibilitat.

---

# 8) Serialització i deserialització guiat (exemple “Persona/Adreça” complet)

## 8.1. XML 

**XML d’entrada:**

```xml
<persona>
    <nom>Jaume Aragó</nom>
    <edat>68</edat>
    <adreces>
        <adreca tipus="casa">
            <carrer>Avinguda Datileres</carrer>
            <ciutat>Benizahat</ciutat>
        </adreca>
        <adreca tipus="oficina">
            <carrer>Canto del Bobet</carrer>
            <ciutat>Benigaslo</ciutat>
        </adreca>
    </adreces>
    <notes><![CDATA[Esta és una persona molt important.]]></notes>
</persona>
```

**POJOs + Anotacions XML (per a mapejar exactament):**

```java
// Persona.java
import com.fasterxml.jackson.dataformat.xml.annotation.*;
import java.util.List;

@JacksonXmlRootElement(localName = "persona")
public class Persona {
    @JacksonXmlProperty(localName = "nom")
    private String nom;

    @JacksonXmlProperty(localName = "edat")
    private int edat;

    @JacksonXmlElementWrapper(localName = "adreces") // <adreces> ... </adreces>
    @JacksonXmlProperty(localName = "adreca")        // elements fills <adreca>
    private List<Adreca> adreces;

    @JacksonXmlCData // Volem que vaja dins CDATA
    private String notes;

    public Persona() {}
    // getters/setters...
}

// Adreca.java
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;

public class Adreca {
    @JacksonXmlProperty(isAttribute = true, localName = "tipus") // atribut <adreca tipus="...">
    private String tipus;

    @JacksonXmlProperty(localName = "carrer")
    private String carrer;

    @JacksonXmlProperty(localName = "ciutat")
    private String ciutat;

    public Adreca() {}
    // getters/setters...
}
```

**Deserialitzar l’XML i mostrar-ho**:

```java
// LligXML.java
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import java.io.File;

public class LligXML {
    public static void main(String[] args) throws Exception {
        XmlMapper xml = new XmlMapper();

        // 1) Des de String (útil per a proves o exemples curts)
        String xmlContent = """
            <persona>
              <nom>Jaume Aragó</nom>
              <edat>68</edat>
              <adreces>
                <adreca tipus="casa">
                  <carrer>Avinguda Datileres</carrer>
                  <ciutat>Benizahat</ciutat>
                </adreca>
                <adreca tipus="oficina">
                  <carrer>Canto del Bobet</carrer>
                  <ciutat>Benigaslo</ciutat>
                </adreca>
              </adreces>
              <notes><![CDATA[Esta és una persona molt important.]]></notes>
            </persona>
        """;
        Persona p = xml.readValue(xmlContent, Persona.class);
        System.out.println("Nom: " + p.getNom() + " | Edat: " + p.getEdat());
        for (Adreca a : p.getAdreces()) {
            System.out.println(" - " + a.getTipus() + " → " + a.getCarrer() + " (" + a.getCiutat() + ")");
        }
        System.out.println("Notes: " + p.getNotes());

        // 2) Des de fitxer
        File f = new File("src/main/resources/persona.xml");
        if (f.exists()) {
            Persona p2 = xml.readValue(f, Persona.class);
            System.out.println("Fitxer OK → " + p2.getNom());
        }
    }
}
```

**Serialitzar a XML amb capçalera i indentació:**

```java
// EscriuXML.java
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.io.File;
import java.util.List;

public class EscriuXML {
    public static void main(String[] args) throws Exception {
        Persona p = new Persona();
        p.setNom("Jaume Aragó");
        p.setEdat(68);
        p.setAdreces(List.of(
            crea("casa", "Avinguda Datileres", "Benizahat"),
            crea("oficina", "Canto del Bobet", "Benigaslo")
        ));
        p.setNotes("Aquesta és una persona molt important.");

        XmlMapper xml = new XmlMapper();
        xml.configure(ToXmlGenerator.Feature.WRITE_XML_DECLARATION, true); // <?xml ...?>
        xml.enable(SerializationFeature.INDENT_OUTPUT);

        String out = xml.writeValueAsString(p);
        System.out.println(out);

        xml.writeValue(new File("src/main/resources/persona_out.xml"), p);
    }

    private static Adreca crea(String tipus, String carrer, String ciutat) {
        Adreca a = new Adreca();
        a.setTipus(tipus);
        a.setCarrer(carrer);
        a.setCiutat(ciutat);
        return a;
    }
}
```

## 8.2. JSON 

**POJOs sense anotacions** (nom per defecte = nom del camp):

```java
// Empresa.java
import java.util.List;

public class Empresa {
    private String nom;
    private List<Empleat> empleats;

    public Empresa() {}
    public Empresa(String nom, List<Empleat> empleats) {
        this.nom = nom;
        this.empleats = empleats;
    }
    public String getNom() { return nom; }
    public void setNom(String nom) { this.nom = nom; }
    public List<Empleat> getEmpleats() { return empleats; }
    public void setEmpleats(List<Empleat> empleats) { this.empleats = empleats; }
}

public class Empleat {
    private String nom;
    private int edat;

    public Empleat() {}
    public Empleat(String nom, int edat) { this.nom = nom; this.edat = edat; }
    public String getNom() { return nom; }
    public void setNom(String nom) { this.nom = nom; }
    public int getEdat() { return edat; }
    public void setEdat(int edat) { this.edat = edat; }
}
```

**Serialitzar a JSON amb indentació:**

```java
// EscriuJSON.java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.io.File;
import java.util.List;

public class EscriuJSON {
    public static void main(String[] args) throws Exception {
        Empresa empresa = new Empresa(
            "La mazmorra del Androide",
            List.of(new Empleat("Jaume", 30), new Empleat("Bel", 28))
        );

        ObjectMapper om = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);

        System.out.println(om.writeValueAsString(empresa)); // a consola
        om.writeValue(new File("src/main/resources/empresa.json"), empresa); // a fitxer
    }
}
```

**Deserialitzar JSON des de fitxer:**

```java
// LligJSON.java
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.File;

public class LligJSON {
    public static void main(String[] args) throws Exception {
        File f = new File("src/main/resources/empresa.json");
        if (!f.exists()) {
            System.err.println("No trobe empresa.json. Executa abans EscriuJSON.");
            return;
        }
        ObjectMapper om = new ObjectMapper();
        Empresa emp = om.readValue(f, Empresa.class);

        System.out.println("Empresa: " + emp.getNom());
        for (Empleat e : emp.getEmpleats()) {
            System.out.println(" - " + e.getNom() + " (" + e.getEdat() + ")");
        }
    }
}
```

---

# 9) Annex ràpid: recordatori de mètodes clau (JSON i XML)

* **Serialitzar (objecte → text)**

  * `writeValueAsString(obj)` → `String` (JSON o XML segons Mapper)
  * `writeValue(File, obj)` → escriu a fitxer
  * `writerWithDefaultPrettyPrinter().writeValueAsString(obj)` → “bonic”

* **Deserialitzar (text → objecte)**

  * `readValue(String/File, Classe.class)`
  * `readTree(...)` → arbre (`JsonNode`) quan no tens POJO

* **Configuració habitual**

  * `enable(SerializationFeature.INDENT_OUTPUT)`
  * `registerModule(new JavaTimeModule())`
  * `disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)`
  * **XML**: `configure(ToXmlGenerator.Feature.WRITE_XML_DECLARATION, true)`

---
