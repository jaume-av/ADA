---
title: 2.4.- Jackson. Serialitzant - Deserialitzat.
parent: 2.- Gestió del Contingut
grand_parent: Persistència de Fitxers
has_children: true
layout: default
nav_order: 40
---




# Mapejant amb Jackson 
(Serialització i Deserialització JSON i XML)


Recordem que:

| Procés              | Descripció                            | Exemple                                |
| ------------------- | ------------------------------------- | -------------------------------------- |
| **Serialització**   | Convertir un objecte Java en JSON/XML | `mapper.writeValueAsString(obj)`       |
| **Deserialització** | Convertir JSON/XML en un objecte Java | `mapper.readValue(json, Classe.class)` |


Per a **mapejar** dades estructurades (JSON o XML) a **classes Java (POJOs/DTOs)**. Jackson ens ofereix un **nucli comú** d’anotacions i configuració que serveix tant per a JSON com per a XML, i un **conjunt reduït d’anotacions específiques d’XML** per a casos concrets (atributs, wrapper de llistes, etc.)

Per tant, es poden **reutilitzar les mateixes classes** per als dos formats i només afegir ajustos d’XML quan calga.

---


##  Serialització (Java → JSON/XML) amb Jackson

L’objectiu és convertir **objectes Java** (POJOs/DTOs) a **text**: JSON o XML.
La peça clau és:

* **JSON** → `ObjectMapper` (mòdul jackson-databind)
* **XML** → `XmlMapper` (mòdul jackson-dataformat-xml)

## 4.1. Mètodes essencials (i què retornen)

> No memoritzem, **entenguem**: “write” escriu (serialitza), “read” llig (deserialitza). Les versions “AsString” retornen una **String**; les que no, escriuen a **fitxer** o **flux**.

### Per a JSON (`ObjectMapper`)

| Retorn         | Mètode                                       | Què fa                                                                                                                |
| -------------- | -------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| `String`       | `writeValueAsString(Object value)`           | Converteix l’objecte a **JSON** en una `String`.                                                                      |
| `void`         | `writeValue(File file, Object value)`        | Escriu l’objecte com a **JSON** dins d’un fitxer.                                                                     |
| `void`         | `writeValue(OutputStream out, Object value)` | Escriu el **JSON** cap a un **Stream** (ex: `FileOutputStream`).                                                      |
| `ObjectWriter` | `writerWithDefaultPrettyPrinter()`           | Prepara un **escriptor** que indenta/formateta l’eixida. (S’usa amb `.writeValueAsString(...)` o `.writeValue(...)`.) |

### Per a XML (`XmlMapper`)

És el mateix patró, però amb XML:

| Retorn   | Mètode                                       | Què fa                                           |
| -------- | -------------------------------------------- | ------------------------------------------------ |
| `String` | `writeValueAsString(Object value)`           | Converteix l’objecte a **XML** en una `String`.  |
| `void`   | `writeValue(File file, Object value)`        | Escriu l’objecte com a **XML** dins d’un fitxer. |
| `void`   | `writeValue(OutputStream out, Object value)` | Escriu l’**XML** cap a un **Stream**.            |

> **Truc didàctic:** per a **JSON**, sempre `new ObjectMapper()`. Per a **XML**, sempre `new XmlMapper()`.

## 4.2. Configuració bàsica recomanada (dates, pretty-print, etc.)

* **Indentació bonica**: `mapper.enable(SerializationFeature.INDENT_OUTPUT)` **o** `mapper.writerWithDefaultPrettyPrinter()...`
* **Dates modernes (Java Time API)**: registra `JavaTimeModule` i desactiva timestamps.

```java
// JSON
ObjectMapper json = new ObjectMapper()
        .registerModule(new JavaTimeModule()) // LocalDate, LocalDateTime, ...
        .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS) // 2025-10-13 en lloc de número
        .enable(SerializationFeature.INDENT_OUTPUT); // format identat

// XML
XmlMapper xml = (XmlMapper) new XmlMapper()
        .registerModule(new JavaTimeModule())
        .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
        .enable(SerializationFeature.INDENT_OUTPUT);
```

> **Per què?** Sense `JavaTimeModule`, `LocalDate` dona problemes o ix com a timestamp.
> Amb `INDENT_OUTPUT`, l’eixida és llegible per a classe i exàmens.

## 4.3. Exemple complet JSON i XML

### El nostre POJO senzill

```java
// Producte.java
// POJO sense anotacions. Constructors buits i getters/setters perquè Jackson puga accedir.
public class Producte {
    private String nom;
    private double preu;
    private boolean actiu;

    public Producte() {} // Obligatori per a Jackson (constructor per defecte)

    public Producte(String nom, double preu, boolean actiu) {
        this.nom = nom;
        this.preu = preu;
        this.actiu = actiu;
    }

    public String getNom() { return nom; }
    public void setNom(String nom) { this.nom = nom; }

    public double getPreu() { return preu; }
    public void setPreu(double preu) { this.preu = preu; }

    public boolean isActiu() { return actiu; } // per a booleans, isXxx és OK
    public void setActiu(boolean actiu) { this.actiu = actiu; }
}
```

### Serialitzar a **JSON** (String i Fitxer)

```java
// SerialitzaJSON.java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import java.io.File;

public class SerialitzaJSON {
    public static void main(String[] args) throws Exception {
        // 1) Creem dades Java
        Producte p = new Producte("Raton Gamer", 24.99, true);

        // 2) Configurem l'ObjectMapper
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        mapper.enable(SerializationFeature.INDENT_OUTPUT);

        // 3) Obtenir JSON com a String (per a mostrar per consola/log)
        String json = mapper.writeValueAsString(p); // <-- No toca disc, només genera una String
        System.out.println("JSON en String:");
        System.out.println(json);

        // 4) Escriure JSON a fitxer (src/main/resources és bona ubicació per a dades)
        File out = new File("src/main/resources/producte.json");
        mapper.writeValue(out, p); // <-- Ara sí, a disc
        System.out.println("S'ha guardat a: " + out.getAbsolutePath());
    }
}
```

### Serialitzar a **XML** (String i Fitxer)

```java
// SerialitzaXML.java
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;
import java.io.File;

public class SerialitzaXML {
    public static void main(String[] args) throws Exception {
        Producte p = new Producte("Raton Gamer", 24.99, true);

        XmlMapper xml = new XmlMapper();
        xml.registerModule(new JavaTimeModule());
        xml.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        xml.enable(SerializationFeature.INDENT_OUTPUT);
        // Opcional: afegir la capçalera XML <?xml ...?>
        xml.configure(ToXmlGenerator.Feature.WRITE_XML_DECLARATION, true);

        String xmlString = xml.writeValueAsString(p);
        System.out.println("XML en String:");
        System.out.println(xmlString);

        File out = new File("src/main/resources/producte.xml");
        xml.writeValue(out, p);
        System.out.println("S'ha guardat a: " + out.getAbsolutePath());
    }
}
```

> **Nota XML**: Com que no hem posat anotacions d’XML, Jackson deriva noms d’etiqueta dels **noms de camp**.
> Si després vols `<nom_producte>` en lloc de `<nom>`, tindrem que posar **anotacions XML** (punt 6).

## 4.4. Serialitzar llistes i objectes anidats

```java
// Cataleg.java
import java.util.List;

public class Cataleg {
    private String nom;
    private List<Producte> productes;

    public Cataleg() {}
    public Cataleg(String nom, List<Producte> productes) {
        this.nom = nom;
        this.productes = productes;
    }
    public String getNom() { return nom; }
    public void setNom(String nom) { this.nom = nom; }
    public List<Producte> getProductes() { return productes; }
    public void setProductes(List<Producte> productes) { this.productes = productes; }
}
```

```java
// SerialitzaColleccions.java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.util.List;
import java.io.File;

public class SerialitzaColleccions {
    public static void main(String[] args) throws Exception {
        Cataleg cat = new Cataleg(
            "Perifèrics",
            List.of(
                new Producte("Raton Gamer", 24.99, true),
                new Producte("Teclat Mecànic", 59.90, true)
            )
        );

        ObjectMapper om = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
        // A String
        System.out.println(om.writeValueAsString(cat));
        // A fitxer
        om.writeValue(new File("src/main/resources/cataleg.json"), cat);
    }
}
```

---

#  Deserialització (JSON/XML → Java)

Ara fem el camí contrari: **a partir d’un text** (JSON o XML) o un **fitxer**, Jackson crea **objectes Java**.

## 5.1. Mètodes de lectura

### JSON (`ObjectMapper`)

| Retorn     | Mètode                                          | Què fa                                                                |
| ---------- | ----------------------------------------------- | --------------------------------------------------------------------- |
| `<T>`      | `readValue(String content, Class<T> valueType)` | Converteix una **String JSON** a un objecte Java.                     |
| `<T>`      | `readValue(File src, Class<T> valueType)`       | Converteix un **fitxer JSON** a un objecte Java.                      |
| `JsonNode` | `readTree(String/Reader/File/InputStream)`      | Llig el JSON com a **arbre** (quan no tens POJO o vols inspeccionar). |

### XML (`XmlMapper`)

Exactament igual, però amb `XmlMapper`.

## 5.2. Deserialitzar JSON (String i Fitxer)

```java
// DeserialitzaJSON.java
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.File;

public class DeserialitzaJSON {
    public static void main(String[] args) throws Exception {
        ObjectMapper om = new ObjectMapper();

        // 1) Des de String
        String json = """
          { "nom": "Raton Gamer", "preu": 24.99, "actiu": true }
        """;
        Producte p = om.readValue(json, Producte.class);
        System.out.println("Nom: " + p.getNom() + ", preu: " + p.getPreu());

        // 2) Des de Fitxer
        File f = new File("src/main/resources/producte.json");
        if (f.exists()) {
            Producte p2 = om.readValue(f, Producte.class);
            System.out.println("Des de fitxer → " + p2.getNom());
        } else {
            System.err.println("No trobe el fitxer producte.json");
        }
    }
}
```

## 5.3. Deserialitzar XML (String i Fitxer)

```java
// DeserialitzaXML.java
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import java.io.File;

public class DeserialitzaXML {
    public static void main(String[] args) throws Exception {
        XmlMapper xml = new XmlMapper();

        String xmlString = """
          <Producte>
            <nom>Raton Gamer</nom>
            <preu>24.99</preu>
            <actiu>true</actiu>
          </Producte>
        """;

        Producte p = xml.readValue(xmlString, Producte.class);
        System.out.println("Nom: " + p.getNom() + ", actiu: " + p.isActiu());

        File f = new File("src/main/resources/producte.xml");
        if (f.exists()) {
            Producte p2 = xml.readValue(f, Producte.class);
            System.out.println("Des de fitxer → " + p2.getNom());
        }
    }
}
```

## 5.4. Lectors/escriptors configurables (ObjectReader/ObjectWriter)

Per a codi net i reutilitzable:

```java
ObjectMapper om = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
var writer = om.writer(); // o om.writerWithDefaultPrettyPrinter()
var reader = om.readerFor(Producte.class);

String json = writer.writeValueAsString(new Producte("X", 1.0, true));
Producte p = reader.readValue(json);
```

## 5.5. Quan **no tens POJOs** o el JSON és “lliure”: `JsonNode`

```java
// Llegir sense classe, recorrent l'arbre
import com.fasterxml.jackson.databind.*;

public class LlegirComArbre {
    public static void main(String[] args) throws Exception {
        String json = """
          { "ciutat":"Madrid", "temperatures":[19,21,18,23,20] }
        """;
        ObjectMapper om = new ObjectMapper();
        JsonNode root = om.readTree(json); // Arrel de l’arbre

        String ciutat = root.get("ciutat").asText();
        System.out.println("Ciutat: " + ciutat);

        // Iterar l'array
        for (JsonNode t : root.withArray("temperatures")) {
            System.out.println("Temp: " + t.asInt());
        }
    }
}
```

---

# 6) Anotacions essencials (JSON i XML) – Quan i per què usar-les

**Filosofia:** primer veiem el comportament per defecte; **després** personalitzem.

## 6.1. JSON (paquet `com.fasterxml.jackson.annotation`)

* `@JsonProperty("clau_json")` → canvia el **nom** de la clau.
* `@JsonIgnore` → exclou un camp (serialitzar i/o deserialitzar).
* `@JsonInclude(Include.NON_NULL/NON_EMPTY/NON_DEFAULT)` → omet nuls/buits/per defecte.
* `@JsonFormat(pattern="dd-MM-yyyy")` → format de dates/nombres.
* `@JsonSetter` i `@JsonGetter` → mapegen getters/setters amb nom personalitzat.
* `@JsonAnySetter` / `@JsonAnyGetter` → propietats desconegudes cap a un `Map`.
* `@JsonIgnoreProperties({"a","b"})` → ignora moltes propietats d’un colp.
* `@JsonAutoDetect` → visibilitat de camps/getters/setters.
* `@JsonSerialize(using=...)` / `@JsonDeserialize(using=...)` → personalitzar (de)serialització.

**Mini-exemple:**

```java
import com.fasterxml.jackson.annotation.*;

@JsonIgnoreProperties({"intern"}) // No expose "intern"
public class Alumne {
    @JsonProperty("nom_complet")
    private String nom;
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String email; // si és null, no ix

    // getters/setters/constructor buit...
}
```

## 6.2. XML (paquet `com.fasterxml.jackson.dataformat.xml.annotation`)

* `@JacksonXmlRootElement(localName="arrel")` → nom de l’element arrel.
* `@JacksonXmlProperty(localName="...")` → nom de subelement **o** `isAttribute=true` per a **atributs**.
* `@JacksonXmlElementWrapper(localName="contenidor")` → embolcall per a **col·leccions** (`List`, `Set`, …).
* `@JacksonXmlText` → el valor és text intern de l’element.
* `@JacksonXmlCData` → escriure contingut com a **CDATA**.

**Mini-exemple:**

```java
import com.fasterxml.jackson.dataformat.xml.annotation.*;

@JacksonXmlRootElement(localName = "persona")
public class Persona {
    @JacksonXmlProperty(localName = "nom")
    private String nom;

    @JacksonXmlElementWrapper(localName = "adreces")
    @JacksonXmlProperty(localName = "adreca")
    private java.util.List<Adreca> adreces;

    @JacksonXmlCData
    private String notes;

    // getters/setters/ctor...
}

class Adreca {
    @JacksonXmlProperty(isAttribute = true, localName = "tipus")
    private String tipus;
    @JacksonXmlProperty(localName = "carrer")
    private String carrer;
    @JacksonXmlProperty(localName = "ciutat")
    private String ciutat;
    // getters/setters/ctor...
}
```

---

# 7) Bones pràctiques i errors típics (que veurem a classe)

* **Constructor buit** als POJOs: sense ell, Jackson no pot crear l’objecte.
* **Getters/Setters** coherents (especialment booleans amb `isXxx`).
* **Rutes de fitxer**: usa `src/main/resources` per a dades; en proves, comprova `exists()`.
* **Dates**: `JavaTimeModule` + `WRITE_DATES_AS_TIMESTAMPS` **desactivat**.
* **Col·leccions**: per a XML, quasi sempre necessitaràs `@JacksonXmlElementWrapper` + `@JacksonXmlProperty`.
* **Estructures desconegudes**: si no tens POJOs, `JsonNode` és el teu amic.
* **Pretty-print**: `INDENT_OUTPUT` o `writerWithDefaultPrettyPrinter()` per a llegibilitat.

---

# 8) Serialització i deserialització guiat (exemple “Persona/Adreça” complet)

## 8.1. XML 

**XML d’entrada:**

```xml
<persona>
    <nom>Jaume Aragó</nom>
    <edat>68</edat>
    <adreces>
        <adreca tipus="casa">
            <carrer>Avinguda Datileres</carrer>
            <ciutat>Benizahat</ciutat>
        </adreca>
        <adreca tipus="oficina">
            <carrer>Canto del Bobet</carrer>
            <ciutat>Benigaslo</ciutat>
        </adreca>
    </adreces>
    <notes><![CDATA[Esta és una persona molt important.]]></notes>
</persona>
```

**POJOs + Anotacions XML (per a mapejar exactament):**

```java
// Persona.java
import com.fasterxml.jackson.dataformat.xml.annotation.*;
import java.util.List;

@JacksonXmlRootElement(localName = "persona")
public class Persona {
    @JacksonXmlProperty(localName = "nom")
    private String nom;

    @JacksonXmlProperty(localName = "edat")
    private int edat;

    @JacksonXmlElementWrapper(localName = "adreces") // <adreces> ... </adreces>
    @JacksonXmlProperty(localName = "adreca")        // elements fills <adreca>
    private List<Adreca> adreces;

    @JacksonXmlCData // Volem que vaja dins CDATA
    private String notes;

    public Persona() {}
    // getters/setters...
}

// Adreca.java
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;

public class Adreca {
    @JacksonXmlProperty(isAttribute = true, localName = "tipus") // atribut <adreca tipus="...">
    private String tipus;

    @JacksonXmlProperty(localName = "carrer")
    private String carrer;

    @JacksonXmlProperty(localName = "ciutat")
    private String ciutat;

    public Adreca() {}
    // getters/setters...
}
```

**Deserialitzar l’XML i mostrar-ho**:

```java
// LligXML.java
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import java.io.File;

public class LligXML {
    public static void main(String[] args) throws Exception {
        XmlMapper xml = new XmlMapper();

        // 1) Des de String (útil per a proves o exemples curts)
        String xmlContent = """
            <persona>
              <nom>Jaume Aragó</nom>
              <edat>68</edat>
              <adreces>
                <adreca tipus="casa">
                  <carrer>Avinguda Datileres</carrer>
                  <ciutat>Benizahat</ciutat>
                </adreca>
                <adreca tipus="oficina">
                  <carrer>Canto del Bobet</carrer>
                  <ciutat>Benigaslo</ciutat>
                </adreca>
              </adreces>
              <notes><![CDATA[Esta és una persona molt important.]]></notes>
            </persona>
        """;
        Persona p = xml.readValue(xmlContent, Persona.class);
        System.out.println("Nom: " + p.getNom() + " | Edat: " + p.getEdat());
        for (Adreca a : p.getAdreces()) {
            System.out.println(" - " + a.getTipus() + " → " + a.getCarrer() + " (" + a.getCiutat() + ")");
        }
        System.out.println("Notes: " + p.getNotes());

        // 2) Des de fitxer
        File f = new File("src/main/resources/persona.xml");
        if (f.exists()) {
            Persona p2 = xml.readValue(f, Persona.class);
            System.out.println("Fitxer OK → " + p2.getNom());
        }
    }
}
```

**Serialitzar a XML amb capçalera i indentació:**

```java
// EscriuXML.java
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.io.File;
import java.util.List;

public class EscriuXML {
    public static void main(String[] args) throws Exception {
        Persona p = new Persona();
        p.setNom("Jaume Aragó");
        p.setEdat(68);
        p.setAdreces(List.of(
            crea("casa", "Avinguda Datileres", "Benizahat"),
            crea("oficina", "Canto del Bobet", "Benigaslo")
        ));
        p.setNotes("Aquesta és una persona molt important.");

        XmlMapper xml = new XmlMapper();
        xml.configure(ToXmlGenerator.Feature.WRITE_XML_DECLARATION, true); // <?xml ...?>
        xml.enable(SerializationFeature.INDENT_OUTPUT);

        String out = xml.writeValueAsString(p);
        System.out.println(out);

        xml.writeValue(new File("src/main/resources/persona_out.xml"), p);
    }

    private static Adreca crea(String tipus, String carrer, String ciutat) {
        Adreca a = new Adreca();
        a.setTipus(tipus);
        a.setCarrer(carrer);
        a.setCiutat(ciutat);
        return a;
    }
}
```

## 8.2. JSON 

**POJOs sense anotacions** (nom per defecte = nom del camp):

```java
// Empresa.java
import java.util.List;

public class Empresa {
    private String nom;
    private List<Empleat> empleats;

    public Empresa() {}
    public Empresa(String nom, List<Empleat> empleats) {
        this.nom = nom;
        this.empleats = empleats;
    }
    public String getNom() { return nom; }
    public void setNom(String nom) { this.nom = nom; }
    public List<Empleat> getEmpleats() { return empleats; }
    public void setEmpleats(List<Empleat> empleats) { this.empleats = empleats; }
}

public class Empleat {
    private String nom;
    private int edat;

    public Empleat() {}
    public Empleat(String nom, int edat) { this.nom = nom; this.edat = edat; }
    public String getNom() { return nom; }
    public void setNom(String nom) { this.nom = nom; }
    public int getEdat() { return edat; }
    public void setEdat(int edat) { this.edat = edat; }
}
```

**Serialitzar a JSON amb indentació:**

```java
// EscriuJSON.java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.io.File;
import java.util.List;

public class EscriuJSON {
    public static void main(String[] args) throws Exception {
        Empresa empresa = new Empresa(
            "La mazmorra del Androide",
            List.of(new Empleat("Jaume", 30), new Empleat("Bel", 28))
        );

        ObjectMapper om = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);

        System.out.println(om.writeValueAsString(empresa)); // a consola
        om.writeValue(new File("src/main/resources/empresa.json"), empresa); // a fitxer
    }
}
```

**Deserialitzar JSON des de fitxer:**

```java
// LligJSON.java
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.File;

public class LligJSON {
    public static void main(String[] args) throws Exception {
        File f = new File("src/main/resources/empresa.json");
        if (!f.exists()) {
            System.err.println("No trobe empresa.json. Executa abans EscriuJSON.");
            return;
        }
        ObjectMapper om = new ObjectMapper();
        Empresa emp = om.readValue(f, Empresa.class);

        System.out.println("Empresa: " + emp.getNom());
        for (Empleat e : emp.getEmpleats()) {
            System.out.println(" - " + e.getNom() + " (" + e.getEdat() + ")");
        }
    }
}
```

---

# 9) Annex ràpid: recordatori de mètodes clau (JSON i XML)

* **Serialitzar (objecte → text)**

  * `writeValueAsString(obj)` → `String` (JSON o XML segons Mapper)
  * `writeValue(File, obj)` → escriu a fitxer
  * `writerWithDefaultPrettyPrinter().writeValueAsString(obj)` → “bonic”

* **Deserialitzar (text → objecte)**

  * `readValue(String/File, Classe.class)`
  * `readTree(...)` → arbre (`JsonNode`) quan no tens POJO

* **Configuració habitual**

  * `enable(SerializationFeature.INDENT_OUTPUT)`
  * `registerModule(new JavaTimeModule())`
  * `disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)`
  * **XML**: `configure(ToXmlGenerator.Feature.WRITE_XML_DECLARATION, true)`

---
